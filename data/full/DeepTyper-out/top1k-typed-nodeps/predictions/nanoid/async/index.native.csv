importKeyword
 Text.Whitespace
{Punctuation
 Text.Whitespace
getRandomBytesAsyncName.Otherany0.5474string0.0655number0.0655boolean0.0321complex0.0227
 Text.Whitespace
}Punctuation
 Text.Whitespace
fromKeyword.Reserved
 Text.Whitespace
'expo-random'Literal.String.Single
\n\nText.Whitespace
importKeyword
 Text.Whitespace
{Punctuation
 Text.Whitespace
urlAlphabetName.Otherany0.5512string0.1060number0.0754string[]0.0249boolean0.0249
 Text.Whitespace
}Punctuation
 Text.Whitespace
fromKeyword.Reserved
 Text.Whitespace
'../url-alphabet/index.js'Literal.String.Single
\n\nText.Whitespace
exportKeyword
 Text.Whitespace
letKeyword.Declaration
 Text.Whitespace
randomName.Otherany0.5520number0.3007string0.0088T0.0076complex0.0056
 Text.Whitespace
=Operator
 Text.Whitespace
getRandomBytesAsyncName.Otherany0.7374number0.0701string0.0094complex0.0035symbol0.0024
\n\nText.Whitespace
exportKeyword
 Text.Whitespace
letKeyword.Declaration
 Text.Whitespace
customAlphabetName.Othernumber0.7009string0.0788any0.0613boolean0.0098string[]0.0065
 Text.Whitespace
=Operator
 Text.Whitespace
(Punctuation
alphabetName.Othernumber0.6538string0.1328any0.1226boolean0.0033string[]0.0023
,Punctuation
 Text.Whitespace
defaultSizeName.Othernumber0.9704any0.0130string0.0109boolean0.0011number[]0.0002
 Text.Whitespace
=Operator
 Text.Whitespace
21Literal.Number.Float
)Punctuation
 Text.Whitespace
=>Punctuation
 Text.Whitespace
{Punctuation
\n  Text.Whitespace
// First, a bitmask is necessary to generate the ID. The bitmask makes bytesComment.Single
\n  Text.Whitespace
// values closer to the alphabet size. The bitmask calculates the closestComment.Single
\n  Text.Whitespace
// `2^31 - 1` number, which exceeds the alphabet size.Comment.Single
\n  Text.Whitespace
// For example, the bitmask for the alphabet size 30 is 31 (00011111).Comment.Single
\n  Text.Whitespace
letKeyword.Declaration
 Text.Whitespace
maskName.Othernumber0.9531string0.0229any0.0180boolean0.0033void0.0003
 Text.Whitespace
=Operator
 Text.Whitespace
(Punctuation
2Literal.Number.Float
 Text.Whitespace
<<Operator
 Text.Whitespace
(Punctuation
31Literal.Number.Float
 Text.Whitespace
-Operator
 Text.Whitespace
MathName.BuiltinMath0.9998number0.0000any0.0000ArrayConstructor0.0000NumberConstructor0.0000
.Punctuation
clz32Name.Othernumber0.9015number[]0.0114complex0.0090string0.0073string[]0.0072
(Punctuation
(Punctuation
alphabetName.Otherstring[]0.4312any0.2037number[]0.0871number0.0779string0.0450
.Punctuation
lengthName.Othernumber0.9847any0.0142string0.0006complex0.0001boolean0.0001
 Text.Whitespace
-Operator
 Text.Whitespace
1Literal.Number.Float
)Punctuation
 Text.Whitespace
|Operator
 Text.Whitespace
1Literal.Number.Float
)Punctuation
)Punctuation
)Punctuation
 Text.Whitespace
-Operator
 Text.Whitespace
1Literal.Number.Float
\n  Text.Whitespace
// Though, the bitmask solution is not perfect since the bytes exceedingComment.Single
\n  Text.Whitespace
// the alphabet size are refused. Therefore, to reliably generate the ID,Comment.Single
\n  Text.Whitespace
// the random bytes redundancy has to be satisfied.Comment.Single
\n\n  Text.Whitespace
// Note: every hardware random generator call is performance expensive,Comment.Single
\n  Text.Whitespace
// because the system call for entropy collection takes a lot of time.Comment.Single
\n  Text.Whitespace
// So, to avoid additional system calls, extra bytes are requested in advance.Comment.Single
\n\n  Text.Whitespace
// Next, a step determines how many random bytes to generate.Comment.Single
\n  Text.Whitespace
// The number of random bytes gets decided upon the ID size, mask,Comment.Single
\n  Text.Whitespace
// alphabet size, and magic number 1.6 (using 1.6 peaks at performanceComment.Single
\n  Text.Whitespace
// according to benchmarks).Comment.Single
\n  Text.Whitespace
letKeyword.Declaration
 Text.Whitespace
stepName.Othernumber0.9950any0.0031string0.0011boolean0.0003void0.0001
 Text.Whitespace
=Operator
 Text.Whitespace
MathName.BuiltinMath1.0000number0.0000ArrayConstructor0.0000PointerCoordinates0.0000NumberConstructor0.0000
.Punctuation
ceilName.Othernumber0.9973any0.0006string0.0003complex0.0003boolean0.0002
(Punctuation
(Punctuation
1.6Literal.Number.Float
 Text.Whitespace
*Operator
 Text.Whitespace
maskName.Othernumber0.9662any0.0298string0.0031boolean0.0002complex0.0001
 Text.Whitespace
*Operator
 Text.Whitespace
defaultSizeName.Othernumber0.9744any0.0153string0.0075complex0.0005number[]0.0004
)Punctuation
 Text.Whitespace
/Operator
 Text.Whitespace
alphabetName.Otherany0.2729number0.2495string[]0.1606string0.1196number[]0.0461
.Punctuation
lengthName.Othernumber0.9829any0.0156string0.0009complex0.0001void0.0001
)Punctuation
\n\n  Text.Whitespace
letKeyword.Declaration
 Text.Whitespace
tickName.Otherany0.8199number0.1178Promise<any>0.0226string0.0088Promise<number>0.0049
 Text.Whitespace
=Operator
 Text.Whitespace
(Punctuation
idName.Othernumber0.7062string0.2223any0.0670complex0.0016number[]0.0005
,Punctuation
 Text.Whitespace
sizeName.Othernumber0.9613string0.0198any0.0176complex0.0003boolean0.0003
 Text.Whitespace
=Operator
 Text.Whitespace
defaultSizeName.Othernumber0.9421string0.0359any0.0190boolean0.0009complex0.0003
)Punctuation
 Text.Whitespace
=>Punctuation
\n    Text.Whitespace
randomName.Otherany0.7658number0.1827Promise<any>0.0055string0.0032Promise<number>0.0030
(Punctuation
stepName.Othernumber0.9616string0.0204any0.0096boolean0.0007void0.0006
)Punctuation
.Punctuation
thenName.Otherany0.9886complex0.0063number0.0022Promise<any>0.0005void0.0004
(Punctuation
bytesName.Otherany0.4238number0.1897complex0.0193number[]0.0192string0.0187
 Text.Whitespace
=>Punctuation
 Text.Whitespace
{Punctuation
\n      Text.Whitespace
// A compact alternative for `for (var i = 0; i < step; i++)`.Comment.Single
\n      Text.Whitespace
letKeyword.Declaration
 Text.Whitespace
iName.Othernumber0.9828any0.0150string0.0012boolean0.0008complex0.0001
 Text.Whitespace
=Operator
 Text.Whitespace
stepName.Othernumber0.9727any0.0192string0.0060boolean0.0006void0.0004
\n      Text.Whitespace
whileKeyword
 Text.Whitespace
(Punctuation
iName.Othernumber0.9794any0.0194string0.0004boolean0.0004complex0.0001
--Operator
)Punctuation
 Text.Whitespace
{Punctuation
\n        Text.Whitespace
// Adding `|| ''` refuses a random byte that exceeds the alphabet size.Comment.Single
\n        Text.Whitespace
idName.Otherstring0.5467number0.3720any0.0783complex0.0010boolean0.0006
 Text.Whitespace
+=Operator
 Text.Whitespace
alphabetName.Otherany0.4150number0.1630complex0.1371string0.0988string[]0.0329
[Punctuation
bytesName.Othernumber[]0.1968any0.1619string[]0.0737number0.0424complex0.0375
[Punctuation
iName.Othernumber0.9891any0.0064string0.0040boolean0.0001complex0.0000
]Punctuation
 Text.Whitespace
&Operator
 Text.Whitespace
maskName.Othernumber0.6713any0.1963string0.1250boolean0.0005Date0.0004
]Punctuation
 Text.Whitespace
||Operator
 Text.Whitespace
''Literal.String.Single
\n        Text.Whitespace
ifKeyword
 Text.Whitespace
(Punctuation
idName.Otherstring0.8365any0.0911number0.0545string[]0.0076number[]0.0025
.Punctuation
lengthName.Othernumber0.9751any0.0218string0.0025complex0.0002void0.0001
 Text.Whitespace
===Operator
 Text.Whitespace
sizeName.Othernumber0.9387string0.0358any0.0236complex0.0008number[]0.0002
)Punctuation
 Text.Whitespace
returnKeyword
 Text.Whitespace
idName.Othernumber0.5304string0.3401any0.1230complex0.0015void0.0006
\n      Text.Whitespace
}Punctuation
\n      Text.Whitespace
returnKeyword
 Text.Whitespace
tickName.Otherany0.6451number0.0904Promise<any>0.0640Promise<number>0.0530Promise<{}>0.0280
(Punctuation
idName.Othernumber0.5699string0.3572any0.0661complex0.0029number[]0.0006
,Punctuation
 Text.Whitespace
sizeName.Othernumber0.9178string0.0586any0.0202complex0.0015number[]0.0004
)Punctuation
\n    Text.Whitespace
}Punctuation
)Punctuation
\n\n  Text.Whitespace
returnKeyword
 Text.Whitespace
sizeName.Othernumber0.6865any0.1638string0.1419complex0.0008number[]0.0008
 Text.Whitespace
=>Punctuation
 Text.Whitespace
tickName.Otherany0.7219number0.0786Promise<any>0.0479Promise<number>0.0249Promise<{}>0.0181
(Punctuation
''Literal.String.Single
,Punctuation
 Text.Whitespace
sizeName.Othernumber0.9801string0.0124any0.0060complex0.0004number[]0.0003
)Punctuation
\nText.Whitespace
}Punctuation
\n\nText.Whitespace
exportKeyword
 Text.Whitespace
letKeyword.Declaration
 Text.Whitespace
nanoidName.Othernumber0.6852any0.1424string0.0485Promise<any>0.0119number[]0.0052
 Text.Whitespace
=Operator
 Text.Whitespace
(Punctuation
sizeName.Othernumber0.9900any0.0050string0.0041boolean0.0002number[]0.0001
 Text.Whitespace
=Operator
 Text.Whitespace
21Literal.Number.Float
)Punctuation
 Text.Whitespace
=>Punctuation
\n  Text.Whitespace
randomName.Otherany0.7783number0.0969Promise<any>0.0286string0.0078Promise<void>0.0062
(Punctuation
sizeName.Othernumber0.8651string0.1094any0.0215boolean0.0008complex0.0003
)Punctuation
.Punctuation
thenName.Otherany0.9872complex0.0063number0.0026Promise<any>0.0006void0.0005
(Punctuation
bytesName.Otherany0.1800number0.1481number[]0.0308complex0.0270any[]0.0257
 Text.Whitespace
=>Punctuation
 Text.Whitespace
{Punctuation
\n    Text.Whitespace
letKeyword.Declaration
 Text.Whitespace
idName.Otherstring0.9061number0.0602any0.0305complex0.0012boolean0.0010
 Text.Whitespace
=Operator
 Text.Whitespace
''Literal.String.Single
\n    Text.Whitespace
// A compact alternative for `for (var i = 0; i < step; i++)`.Comment.Single
\n    Text.Whitespace
whileKeyword
 Text.Whitespace
(Punctuation
sizeName.Othernumber0.9888any0.0083string0.0020boolean0.0003complex0.0001
--Operator
)Punctuation
 Text.Whitespace
{Punctuation
\n      Text.Whitespace
// It is incorrect to use bytes exceeding the alphabet size.Comment.Single
\n      Text.Whitespace
// The following mask reduces the random byte in the 0-255 valueComment.Single
\n      Text.Whitespace
// range to the 0-63 value range. Therefore, adding hacks, suchComment.Single
\n      Text.Whitespace
// as empty string fallback or magic numbers, is unneccessary becauseComment.Single
\n      Text.Whitespace
// the bitmask trims bytes down to the alphabet size.Comment.Single
\n      Text.Whitespace
idName.Otherstring0.6282number0.3179any0.0505complex0.0012boolean0.0007
 Text.Whitespace
+=Operator
 Text.Whitespace
urlAlphabetName.Otherany0.2765number0.2567string0.1563complex0.0696string[]0.0639
[Punctuation
bytesName.Otherany0.2100number[]0.1968complex0.0827number0.0699string[]0.0371
[Punctuation
sizeName.Othernumber0.9136string0.0741any0.0106complex0.0003boolean0.0002
]Punctuation
 Text.Whitespace
&Operator
 Text.Whitespace
63Literal.Number.Float
]Punctuation
\n    Text.Whitespace
}Punctuation
\n    Text.Whitespace
returnKeyword
 Text.Whitespace
idName.Otherstring0.6047number0.3060any0.0788complex0.0034boolean0.0009
\n  Text.Whitespace
}Punctuation
)Punctuation
\nText.Whitespace
