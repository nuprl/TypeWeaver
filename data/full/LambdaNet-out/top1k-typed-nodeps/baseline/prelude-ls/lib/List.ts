// Generated by LiveScript 1.6.0
var each: object, map: any[], compact: Function, filter: object, reject: object, remove: string, partition: any[], find: object, head: object, first: object, tail: Function, last: Function, initial: Function, empty: Function, reverse: Function, unique: Function, uniqueBy: any[], fold: Function, foldl: any[], fold1: any[], foldl1: any[], foldr: Function, foldr1: any[], unfoldr: any[], concat: object, concatMap: object, flatten: Function, difference: Function, intersection: Function, union: Function, countBy: string, groupBy: any[], andList: Function, orList: Function, any: object, all: object, sort: Function, sortWith: Function, sortBy: string, sum: Function, product: Function, mean: any[], average: Function, maximum: Function, minimum: Function, maximumBy: any[], minimumBy: any[], scan: Function, scanl: any[], scan1: any[], scanl1: any[], scanr: any[], scanr1: any[], slice: any[], take: Function, drop: Function, splitAt: number, takeWhile: Function, dropWhile: Function, span: Function, breakList: any[], zip: any[], zipWith: object, zipAll: Function, zipAllWith: Function, at: object, elemIndex: Function, elemIndices: any[], findIndex: number, findIndices: any[], toString$: Function = {}.toString;
each = curry$(function(f: Function, xs: any[]){
  var i$: number, len$: Function, x: string;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    f(x);
  }
  return xs;
});
map = curry$(function(f: Function, xs: any[]){
  var i$: number, len$: Function, x: string, results$: any[] = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    results$.push(f(x));
  }
  return results$;
});
compact = function(xs: any[]){
  var i$: number, len$: Function, x: string, results$: any[] = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (x) {
      results$.push(x);
    }
  }
  return results$;
};
filter = curry$(function(f: Function, xs: any[]){
  var i$: number, len$: Function, x: string, results$: any[] = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      results$.push(x);
    }
  }
  return results$;
});
reject = curry$(function(f: Function, xs: any[]){
  var i$: number, len$: Function, x: string, results$: any[] = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!f(x)) {
      results$.push(x);
    }
  }
  return results$;
});
remove = curry$(function(el: any[], xs: object){
  var i: number, x$: any[];
  i = elemIndex(el, xs);
  x$ = xs.slice();
  if (i != null) {
    x$.splice(i, 1);
  }
  return x$;
});
partition = curry$(function(f: Function, xs: any[]){
  var passed: any[], failed: any[], i$: number, len$: Function, x: string;
  passed = [];
  failed = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    (f(x) ? passed : failed).push(x);
  }
  return [passed, failed];
});
find = curry$(function(f: Function, xs: any[]){
  var i$: number, len$: Function, x: string;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      return x;
    }
  }
});
head = first = function(xs: Promise){
  return xs[0];
};
tail = function(xs: any[]){
  if (!xs.length) {
    return;
  }
  return xs.slice(1);
};
last = function(xs: any[]){
  return xs[xs.length - 1];
};
initial = function(xs: any[]){
  if (!xs.length) {
    return;
  }
  return xs.slice(0, -1);
};
empty = function(xs: any[]){
  return !xs.length;
};
reverse = function(xs: Promise){
  return xs.concat().reverse();
};
unique = function(xs: any[]){
  var result: any[], i$: number, len$: Function, x: string;
  result = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!in$(x, result)) {
      result.push(x);
    }
  }
  return result;
};
uniqueBy = curry$(function(f: Function, xs: any[]){
  var seen: any[], i$: number, len$: Function, x: string, val: string, results$: any[] = [];
  seen = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    val = f(x);
    if (in$(val, seen)) {
      continue;
    }
    seen.push(val);
    results$.push(x);
  }
  return results$;
});
fold = foldl = curry$(function(f: Function, memo: number, xs: any[]){
  var i$: number, len$: Function, x: string;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    memo = f(memo, x);
  }
  return memo;
});
fold1 = foldl1 = curry$(function(f: number, xs: any[]){
  return fold(f, xs[0], xs.slice(1));
});
foldr = curry$(function(f: Function, memo: number, xs: any[]){
  var i$: number, x: string;
  for (i$ = xs.length - 1; i$ >= 0; --i$) {
    x = xs[i$];
    memo = f(x, memo);
  }
  return memo;
});
foldr1 = curry$(function(f: number, xs: any[]){
  return foldr(f, xs[xs.length - 1], xs.slice(0, -1));
});
unfoldr = curry$(function(f: Function, b: string){
  var result: any[], x: string, that: object;
  result = [];
  x = b;
  while ((that = f(x)) != null) {
    result.push(that[0]);
    x = that[1];
  }
  return result;
});
concat = function(xss: Function){
  return [].concat.apply([], xss);
};
concatMap = curry$(function(f: Function, xs: Function){
  var x: string;
  return [].concat.apply([], (function(){
    var i$: number, ref$: object, len$: Function, results$: any[] = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(f(x));
    }
    return results$;
  }()));
});
flatten = function(xs: Function){
  var x: string;
  return [].concat.apply([], (function(){
    var i$: number, ref$: object, len$: Function, results$: any[] = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (toString$.call(x).slice(8, -1) === 'Array') {
        results$.push(flatten(x));
      } else {
        results$.push(x);
      }
    }
    return results$;
  }()));
};
difference = function(xs: any[]){
  var yss: any[], res$: any[], i$: number, to$: Function, results: any[], len$: Function, x: string, j$: number, len1$: Function, ys: Function;
  res$ = [];
  for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
    res$.push(arguments[i$]);
  }
  yss = res$;
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];
      if (in$(x, ys)) {
        continue outer;
      }
    }
    results.push(x);
  }
  return results;
};
intersection = function(xs: any[]){
  var yss: any[], res$: any[], i$: number, to$: Function, results: any[], len$: Function, x: string, j$: number, len1$: Function, ys: Function;
  res$ = [];
  for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
    res$.push(arguments[i$]);
  }
  yss = res$;
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];
      if (!in$(x, ys)) {
        continue outer;
      }
    }
    results.push(x);
  }
  return results;
};
union = function(){
  var xss: any[], res$: any[], i$: number, to$: Function, results: any[], len$: Function, xs: any[], j$: number, len1$: Function, x: string;
  res$ = [];
  for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
    res$.push(arguments[i$]);
  }
  xss = res$;
  results = [];
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    for (j$ = 0, len1$ = xs.length; j$ < len1$; ++j$) {
      x = xs[j$];
      if (!in$(x, results)) {
        results.push(x);
      }
    }
  }
  return results;
};
countBy = curry$(function(f: Function, xs: any[]){
  var results: object, i$: number, len$: Function, x: string, key: string;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);
    if (key in results) {
      results[key] += 1;
    } else {
      results[key] = 1;
    }
  }
  return results;
});
groupBy = curry$(function(f: Function, xs: any[]){
  var results: object, i$: number, len$: Function, x: string, key: string;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);
    if (key in results) {
      results[key].push(x);
    } else {
      results[key] = [x];
    }
  }
  return results;
});
andList = function(xs: any[]){
  var i$: number, len$: Function, x: string;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!x) {
      return false;
    }
  }
  return true;
};
orList = function(xs: any[]){
  var i$: number, len$: Function, x: string;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (x) {
      return true;
    }
  }
  return false;
};
any = curry$(function(f: Function, xs: any[]){
  var i$: number, len$: Function, x: string;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      return true;
    }
  }
  return false;
});
all = curry$(function(f: Function, xs: any[]){
  var i$: number, len$: Function, x: string;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!f(x)) {
      return false;
    }
  }
  return true;
});
sort = function(xs: Promise){
  return xs.concat().sort(function(x: number, y: number){
    if (x > y) {
      return 1;
    } else if (x < y) {
      return -1;
    } else {
      return 0;
    }
  });
};
sortWith = curry$(function(f: string, xs: Promise){
  return xs.concat().sort(f);
});
sortBy = curry$(function(f: Function, xs: Promise){
  return xs.concat().sort(function(x: string, y: string){
    if (f(x) > f(y)) {
      return 1;
    } else if (f(x) < f(y)) {
      return -1;
    } else {
      return 0;
    }
  });
});
sum = function(xs: any[]){
  var result: number, i$: number, len$: Function, x: string;
  result = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result += x;
  }
  return result;
};
product = function(xs: any[]){
  var result: number, i$: number, len$: Function, x: string;
  result = 1;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result *= x;
  }
  return result;
};
mean = average = function(xs: any[]){
  var sum: number, i$: number, len$: Function, x: string;
  sum = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    sum += x;
  }
  return sum / xs.length;
};
maximum = function(xs: any[]){
  var max: number, i$: number, ref$: object, len$: Function, x: number;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (x > max) {
      max = x;
    }
  }
  return max;
};
minimum = function(xs: any[]){
  var min: Function, i$: number, ref$: object, len$: Function, x: Function;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (x < min) {
      min = x;
    }
  }
  return min;
};
maximumBy = curry$(function(f: Function, xs: any[]){
  var max: Function, i$: number, ref$: object, len$: Function, x: Function;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (f(x) > f(max)) {
      max = x;
    }
  }
  return max;
});
minimumBy = curry$(function(f: Function, xs: any[]){
  var min: Function, i$: number, ref$: object, len$: Function, x: Function;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (f(x) < f(min)) {
      min = x;
    }
  }
  return min;
});
scan = scanl = curry$(function(f: Function, memo: string, xs: Function){
  var last: string, x: string;
  last = memo;
  return [memo].concat((function(){
    var i$: number, ref$: object, len$: Function, results$: any[] = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(last = f(last, x));
    }
    return results$;
  }()));
});
scan1 = scanl1 = curry$(function(f: number, xs: any[]){
  if (!xs.length) {
    return;
  }
  return scan(f, xs[0], xs.slice(1));
});
scanr = curry$(function(f: number, memo: number, xs: any[]){
  xs = xs.concat().reverse();
  return scan(f, memo, xs).reverse();
});
scanr1 = curry$(function(f: number, xs: any[]){
  if (!xs.length) {
    return;
  }
  xs = xs.concat().reverse();
  return scan(f, xs[0], xs.slice(1)).reverse();
});
slice = curry$(function(x: string, y: string, xs: any[]){
  return xs.slice(x, y);
});
take = curry$(function(n: number, xs: any[]){
  if (n <= 0) {
    return xs.slice(0, 0);
  } else {
    return xs.slice(0, n);
  }
});
drop = curry$(function(n: number, xs: any[]){
  if (n <= 0) {
    return xs;
  } else {
    return xs.slice(n);
  }
});
splitAt = curry$(function(n: string, xs: number){
  return [take(n, xs), drop(n, xs)];
});
takeWhile = curry$(function(p: Function, xs: any[]){
  var len: number, i: number;
  len = xs.length;
  if (!len) {
    return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
    i += 1;
  }
  return xs.slice(0, i);
});
dropWhile = curry$(function(p: Function, xs: any[]){
  var len: number, i: number;
  len = xs.length;
  if (!len) {
    return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
    i += 1;
  }
  return xs.slice(i);
});
span = curry$(function(p: any[], xs: number){
  return [takeWhile(p, xs), dropWhile(p, xs)];
});
breakList = curry$(function(p: string, xs: any[]){
  return span(compose$(p, not$), xs);
});
zip = curry$(function(xs: any[], ys: any[]){
  var result: any[], len: number, i$: number, len$: Function, i: number, x: string;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (i === len) {
      break;
    }
    result.push([x, ys[i]]);
  }
  return result;
});
zipWith = curry$(function(f: Function, xs: any[], ys: any[]){
  var result: any[], len: number, i$: number, len$: Function, i: number, x: string;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (i === len) {
      break;
    }
    result.push(f(x, ys[i]));
  }
  return result;
});
zipAll = function(){
  var xss: any[], res$: any[], i$: number, to$: Function, minLength: number, len$: Function, xs: any[], ref$: Function, i: number, lresult$: any[], j$: number, results$: any[] = [];
  res$ = [];
  for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
    res$.push(arguments[i$]);
  }
  xss = res$;
  minLength = undefined;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    lresult$ = [];
    for (j$ = 0, len$ = xss.length; j$ < len$; ++j$) {
      xs = xss[j$];
      lresult$.push(xs[i]);
    }
    results$.push(lresult$);
  }
  return results$;
};
zipAllWith = function(f: object){
  var xss: any[], res$: any[], i$: number, to$: Function, minLength: number, len$: Function, xs: any[], ref$: Function, i: number, results$: any[] = [];
  res$ = [];
  for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
    res$.push(arguments[i$]);
  }
  xss = res$;
  minLength = undefined;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    results$.push(f.apply(null, (fn$())));
  }
  return results$;
  function fn$(): any[]{
    var i$: number, ref$: object, len$: Function, results$: any[] = [];
    for (i$ = 0, len$ = (ref$ = xss).length; i$ < len$; ++i$) {
      xs = ref$[i$];
      results$.push(xs[i]);
    }
    return results$;
  }
};
at = curry$(function(n: string, xs: any[]){
  if (n < 0) {
    return xs[xs.length + n];
  } else {
    return xs[n];
  }
});
elemIndex = curry$(function(el: string, xs: any[]){
  var i$: number, len$: Function, i: number, x: string;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (x === el) {
      return i;
    }
  }
});
elemIndices = curry$(function(el: string, xs: any[]){
  var i$: number, len$: Function, i: number, x: string, results$: any[] = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (x === el) {
      results$.push(i);
    }
  }
  return results$;
});
findIndex = curry$(function(f: Function, xs: any[]){
  var i$: number, len$: Function, i: number, x: string;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (f(x)) {
      return i;
    }
  }
});
findIndices = curry$(function(f: Function, xs: any[]){
  var i$: number, len$: Function, i: number, x: string, results$: any[] = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (f(x)) {
      results$.push(i);
    }
  }
  return results$;
});
module.exports = {
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  remove: remove,
  partition: partition,
  find: find,
  head: head,
  first: first,
  tail: tail,
  last: last,
  initial: initial,
  empty: empty,
  reverse: reverse,
  difference: difference,
  intersection: intersection,
  union: union,
  countBy: countBy,
  groupBy: groupBy,
  fold: fold,
  fold1: fold1,
  foldl: foldl,
  foldl1: foldl1,
  foldr: foldr,
  foldr1: foldr1,
  unfoldr: unfoldr,
  andList: andList,
  orList: orList,
  any: any,
  all: all,
  unique: unique,
  uniqueBy: uniqueBy,
  sort: sort,
  sortWith: sortWith,
  sortBy: sortBy,
  sum: sum,
  product: product,
  mean: mean,
  average: average,
  concat: concat,
  concatMap: concatMap,
  flatten: flatten,
  maximum: maximum,
  minimum: minimum,
  maximumBy: maximumBy,
  minimumBy: minimumBy,
  scan: scan,
  scan1: scan1,
  scanl: scanl,
  scanl1: scanl1,
  scanr: scanr,
  scanr1: scanr1,
  slice: slice,
  take: take,
  drop: drop,
  splitAt: splitAt,
  takeWhile: takeWhile,
  dropWhile: dropWhile,
  span: span,
  breakList: breakList,
  zip: zip,
  zipWith: zipWith,
  zipAll: zipAll,
  zipAllWith: zipAllWith,
  at: at,
  elemIndex: elemIndex,
  elemIndices: elemIndices,
  findIndex: findIndex,
  findIndices: findIndices
};
function curry$(f: any[], bound: boolean): boolean{
  var context: string,
  _curry: Function = function(args: Promise) {
    return f.length > 1 ? function(){
      var params: any[] = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
function in$(x: string, xs: any[]): boolean{
  var i: number = -1, l: number = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}
function compose$(): Function {
  var functions: Map = arguments;
  return function() {
    var i: number, result: Function;
    result = functions[0].apply(this, arguments);
    for (i = 1; i < functions.length; ++i) {
      result = functions[i](result);
    }
    return result;
  };
}
function not$(x: number): boolean{ return !x; }