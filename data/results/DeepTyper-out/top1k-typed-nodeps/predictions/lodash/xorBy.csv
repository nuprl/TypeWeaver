importKeyword
 Text.Whitespace
baseXorName.Otherany0.0842complex0.0547boolean0.0321void0.0302string0.0200
 Text.Whitespace
fromKeyword.Reserved
 Text.Whitespace
'./.internal/baseXor.js'Literal.String.Single
\nText.Whitespace
importKeyword
 Text.Whitespace
isArrayLikeObjectName.Otherany0.1248boolean0.0552complex0.0480string0.0343void0.0281
 Text.Whitespace
fromKeyword.Reserved
 Text.Whitespace
'./isArrayLikeObject.js'Literal.String.Single
\nText.Whitespace
importKeyword
 Text.Whitespace
lastName.Otherany0.3297string0.0949complex0.0687void0.0535boolean0.0289
 Text.Whitespace
fromKeyword.Reserved
 Text.Whitespace
'./last.js'Literal.String.Single
\n\nText.Whitespace
Text
/**\n * This method is like `xor` except that it accepts `iteratee` which is\n * invoked for each element of each `arrays` to generate the criterion by\n * which they're compared. The order of result values is determined\n * by the order they occur in the arrays. The iteratee is invoked with one\n * argument: (value).\n *\n * @since 4.0.0\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @param {Function} iteratee The iteratee invoked per element.\n * @returns {Array} Returns the new array of filtered values.\n * @see difference, union, unionBy, unionWith, without, xor, xorWith\n * @example\n *\n * xorBy([2.1, 1.2], [2.3, 3.4], Math.floor)\n * // => [1.2, 3.4]\n */Comment.Multiline
\nText.Whitespace
functionKeyword.Declaration
 Text.Whitespace
xorByName.Otherany0.1597string0.1033complex0.0817boolean0.0393Promise<any>0.0104
(Punctuation
...Punctuation
arraysName.Otherany[]0.3322any0.1627string[]0.0493complex0.0118T[]0.0102
)Punctuation
 Text.Whitespace
{Punctuation
\n  Text.Whitespace
letKeyword.Declaration
 Text.Whitespace
iterateeName.Otherany0.6855string0.0283any[]0.0080complex0.0070{}0.0064
 Text.Whitespace
=Operator
 Text.Whitespace
lastName.Otherany0.7681string0.0527complex0.0296any[]0.0129boolean0.0084
(Punctuation
arraysName.Otherany0.3782any[]0.1795string[]0.0343string0.0271complex0.0192
)Punctuation
\n  Text.Whitespace
ifKeyword
 Text.Whitespace
(Punctuation
isArrayLikeObjectName.Otherboolean0.5267any0.2264complex0.0327string0.0321any[]0.0126
(Punctuation
iterateeName.Otherany0.6533string0.0457complex0.0066any[]0.0059number0.0057
)Punctuation
)Punctuation
 Text.Whitespace
{Punctuation
\n    Text.Whitespace
iterateeName.Otherany0.7410string0.0283{}0.0082any[]0.0069complex0.0063
 Text.Whitespace
=Operator
 Text.Whitespace
undefinedKeyword.Constant
\n  Text.Whitespace
}Punctuation
\n  Text.Whitespace
returnKeyword
 Text.Whitespace
baseXorName.Otherany0.3433complex0.1077any[]0.0574boolean0.0151void0.0092
(Punctuation
arraysName.Otherany0.6003any[]0.1419string[]0.0319complex0.0101string0.0046
.Punctuation
filterName.Otherany0.5177complex0.4263any[]0.0058void0.0039boolean0.0028
(Punctuation
isArrayLikeObjectName.Otherany0.5312boolean0.1101complex0.1001string0.0449any[]0.0384
)Punctuation
,Punctuation
 Text.Whitespace
iterateeName.Otherany0.5085{}0.0610string0.0561any[]0.0204boolean0.0192
)Punctuation
\nText.Whitespace
}Punctuation
\n\nText.Whitespace
exportKeyword
 Text.Whitespace
defaultKeyword
 Text.Whitespace
xorByName.Otherany0.4465boolean0.0236void0.0179string0.0172complex0.0166
\nText.Whitespace
