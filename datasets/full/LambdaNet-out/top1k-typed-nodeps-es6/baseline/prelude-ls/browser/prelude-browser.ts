// Generated by LiveScript 1.6.0

// prelude.ls 1.2.1
// Copyright (c) George Zahariev
// Released under the MIT License
// https://raw.githubusercontent.com/gkz/prelude-ls/master/LICENSE
require=(function(){function r(e: object,n: object,t: any[]): Function{function o(i: string,f: boolean): Function{if(!n[i]){if(!e[i]){var c: Function="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a: Error=new Error("Cannot find module '"+i+"'");throw (a.code="MODULE_NOT_FOUND", a)}var p: object=n[i]={exports:{}};e[i][0].call(p.exports,function(r: string){var n: string=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require: Function,module: Function,exports: number){
  // Generated by LiveScript 1.6.0
  var apply: Function, curry: Function, flip: any[], fix: Function, over: object, memoize: Function, toString$: Function = {}.toString;
  apply = curry$(function(f: object, list: object){
    return f.apply(null, list);
  });
  curry = function(f: Function){
    return curry$(f);
  };
  flip = curry$(function(f: Function, x: string, y: number){
    return f(y, x);
  });
  fix = function(f: Function){
    return function(g: Function){
      return function(){
        return f(g(g)).apply(null, arguments);
      };
    }(function(g: Function){
      return function(){
        return f(g(g)).apply(null, arguments);
      };
    });
  };
  over = curry$(function(f: Function, g: Function, x: string, y: number){
    return f(g(x), g(y));
  });
  memoize = function(f: object){
    var memo: object;
    memo = {};
    return function(){
      var args: any[], res$: any[], i$: number, to$: Function, key: string, arg: string;
      res$ = [];
      for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
        res$.push(arguments[i$]);
      }
      args = res$;
      key = (function(){
        var i$: number, ref$: object, len$: Function, results$: any[] = [];
        for (i$ = 0, len$ = (ref$ = args).length; i$ < len$; ++i$) {
          arg = ref$[i$];
          results$.push(arg + toString$.call(arg).slice(8, -1));
        }
        return results$;
      }()).join('');
      return memo[key] = key in memo
        ? memo[key]
        : f.apply(null, args);
    };
  };

  export default {
    curry: curry,
    flip: flip,
    fix: fix,
    apply: apply,
    over: over,
    memoize: memoize
  };

  function curry$(f: any[], bound: boolean): boolean{
    var context: string,
    _curry: Function = function(args: Promise) {
      return f.length > 1 ? function(){
        var params: any[] = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
},{}],2:[function(require: Function,module: Function,exports: number){
  // Generated by LiveScript 1.6.0
  var each: object, map: any[], compact: Function, filter: object, reject: object, remove: string, partition: any[], find: object, head: object, first: object, tail: Function, last: Function, initial: Function, empty: Function, reverse: Function, unique: Function, uniqueBy: any[], fold: Function, foldl: any[], fold1: any[], foldl1: any[], foldr: Function, foldr1: any[], unfoldr: any[], concat: object, concatMap: object, flatten: Function, difference: Function, intersection: Function, union: Function, countBy: any[], groupBy: any[], andList: Function, orList: Function, any: object, all: object, sort: Function, sortWith: Function, sortBy: string, sum: Function, product: Function, mean: any[], average: Function, maximum: Function, minimum: Function, maximumBy: any[], minimumBy: any[], scan: Function, scanl: any[], scan1: any[], scanl1: any[], scanr: any[], scanr1: any[], slice: any[], take: Function, drop: Function, splitAt: number, takeWhile: Function, dropWhile: Function, span: Function, breakList: any[], zip: any[], zipWith: object, zipAll: Function, zipAllWith: Function, at: object, elemIndex: Function, elemIndices: any[], findIndex: number, findIndices: any[], toString$: Function = {}.toString;
  each = curry$(function(f: Function, xs: any[]){
    var i$: number, len$: Function, x: string;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      f(x);
    }
    return xs;
  });
  map = curry$(function(f: Function, xs: any[]){
    var i$: number, len$: Function, x: string, results$: any[] = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      results$.push(f(x));
    }
    return results$;
  });
  compact = function(xs: any[]){
    var i$: number, len$: Function, x: string, results$: any[] = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      if (x) {
        results$.push(x);
      }
    }
    return results$;
  };
  filter = curry$(function(f: Function, xs: any[]){
    var i$: number, len$: Function, x: string, results$: any[] = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      if (f(x)) {
        results$.push(x);
      }
    }
    return results$;
  });
  reject = curry$(function(f: Function, xs: any[]){
    var i$: number, len$: Function, x: string, results$: any[] = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      if (!f(x)) {
        results$.push(x);
      }
    }
    return results$;
  });
  remove = curry$(function(el: any[], xs: object){
    var i: number, x$: any[];
    i = elemIndex(el, xs);
    x$ = xs.slice();
    if (i != null) {
      x$.splice(i, 1);
    }
    return x$;
  });
  partition = curry$(function(f: Function, xs: any[]){
    var passed: any[], failed: any[], i$: number, len$: Function, x: string;
    passed = [];
    failed = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      (f(x) ? passed : failed).push(x);
    }
    return [passed, failed];
  });
  find = curry$(function(f: Function, xs: any[]){
    var i$: number, len$: Function, x: string;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      if (f(x)) {
        return x;
      }
    }
  });
  head = first = function(xs: Promise){
    return xs[0];
  };
  tail = function(xs: any[]){
    if (!xs.length) {
      return;
    }
    return xs.slice(1);
  };
  last = function(xs: any[]){
    return xs[xs.length - 1];
  };
  initial = function(xs: any[]){
    if (!xs.length) {
      return;
    }
    return xs.slice(0, -1);
  };
  empty = function(xs: any[]){
    return !xs.length;
  };
  reverse = function(xs: Promise){
    return xs.concat().reverse();
  };
  unique = function(xs: any[]){
    var result: any[], i$: number, len$: Function, x: string;
    result = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      if (!in$(x, result)) {
        result.push(x);
      }
    }
    return result;
  };
  uniqueBy = curry$(function(f: Function, xs: any[]){
    var seen: any[], i$: number, len$: Function, x: string, val: string, results$: any[] = [];
    seen = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      val = f(x);
      if (in$(val, seen)) {
        continue;
      }
      seen.push(val);
      results$.push(x);
    }
    return results$;
  });
  fold = foldl = curry$(function(f: Function, memo: number, xs: any[]){
    var i$: number, len$: Function, x: string;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      memo = f(memo, x);
    }
    return memo;
  });
  fold1 = foldl1 = curry$(function(f: number, xs: any[]){
    return fold(f, xs[0], xs.slice(1));
  });
  foldr = curry$(function(f: Function, memo: number, xs: any[]){
    var i$: number, x: string;
    for (i$ = xs.length - 1; i$ >= 0; --i$) {
      x = xs[i$];
      memo = f(x, memo);
    }
    return memo;
  });
  foldr1 = curry$(function(f: number, xs: any[]){
    return foldr(f, xs[xs.length - 1], xs.slice(0, -1));
  });
  unfoldr = curry$(function(f: Function, b: string){
    var result: any[], x: string, that: object;
    result = [];
    x = b;
    while ((that = f(x)) != null) {
      result.push(that[0]);
      x = that[1];
    }
    return result;
  });
  concat = function(xss: string){
    return [].concat.apply([], xss);
  };
  concatMap = curry$(function(f: Function, xs: Function){
    var x: string;
    return [].concat.apply([], (function(){
      var i$: number, ref$: object, len$: Function, results$: any[] = [];
      for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
        x = ref$[i$];
        results$.push(f(x));
      }
      return results$;
    }()));
  });
  flatten = function(xs: Function){
    var x: string;
    return [].concat.apply([], (function(){
      var i$: number, ref$: object, len$: Function, results$: any[] = [];
      for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
        x = ref$[i$];
        if (toString$.call(x).slice(8, -1) === 'Array') {
          results$.push(flatten(x));
        } else {
          results$.push(x);
        }
      }
      return results$;
    }()));
  };
  difference = function(xs: any[]){
    var yss: any[], res$: any[], i$: number, to$: Function, results: any[], len$: Function, x: string, j$: number, len1$: Function, ys: Function;
    res$ = [];
    for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    yss = res$;
    results = [];
    outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
        ys = yss[j$];
        if (in$(x, ys)) {
          continue outer;
        }
      }
      results.push(x);
    }
    return results;
  };
  intersection = function(xs: any[]){
    var yss: any[], res$: any[], i$: number, to$: Function, results: any[], len$: Function, x: string, j$: number, len1$: Function, ys: Function;
    res$ = [];
    for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    yss = res$;
    results = [];
    outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
        ys = yss[j$];
        if (!in$(x, ys)) {
          continue outer;
        }
      }
      results.push(x);
    }
    return results;
  };
  union = function(){
    var xss: any[], res$: any[], i$: number, to$: Function, results: any[], len$: Function, xs: any[], j$: number, len1$: Function, x: string;
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    xss = res$;
    results = [];
    for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
      xs = xss[i$];
      for (j$ = 0, len1$ = xs.length; j$ < len1$; ++j$) {
        x = xs[j$];
        if (!in$(x, results)) {
          results.push(x);
        }
      }
    }
    return results;
  };
  countBy = curry$(function(f: Function, xs: any[]){
    var results: object, i$: number, len$: Function, x: string, key: string;
    results = {};
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      key = f(x);
      if (key in results) {
        results[key] += 1;
      } else {
        results[key] = 1;
      }
    }
    return results;
  });
  groupBy = curry$(function(f: Function, xs: any[]){
    var results: object, i$: number, len$: Function, x: string, key: string;
    results = {};
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      key = f(x);
      if (key in results) {
        results[key].push(x);
      } else {
        results[key] = [x];
      }
    }
    return results;
  });
  andList = function(xs: any[]){
    var i$: number, len$: Function, x: string;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      if (!x) {
        return false;
      }
    }
    return true;
  };
  orList = function(xs: any[]){
    var i$: number, len$: Function, x: string;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      if (x) {
        return true;
      }
    }
    return false;
  };
  any = curry$(function(f: Function, xs: any[]){
    var i$: number, len$: Function, x: string;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      if (f(x)) {
        return true;
      }
    }
    return false;
  });
  all = curry$(function(f: Function, xs: any[]){
    var i$: number, len$: Function, x: string;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      if (!f(x)) {
        return false;
      }
    }
    return true;
  });
  sort = function(xs: Promise){
    return xs.concat().sort(function(x: number, y: number){
      if (x > y) {
        return 1;
      } else if (x < y) {
        return -1;
      } else {
        return 0;
      }
    });
  };
  sortWith = curry$(function(f: string, xs: Promise){
    return xs.concat().sort(f);
  });
  sortBy = curry$(function(f: Function, xs: Promise){
    return xs.concat().sort(function(x: string, y: string){
      if (f(x) > f(y)) {
        return 1;
      } else if (f(x) < f(y)) {
        return -1;
      } else {
        return 0;
      }
    });
  });
  sum = function(xs: any[]){
    var result: number, i$: number, len$: Function, x: string;
    result = 0;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      result += x;
    }
    return result;
  };
  product = function(xs: any[]){
    var result: number, i$: number, len$: Function, x: string;
    result = 1;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      result *= x;
    }
    return result;
  };
  mean = average = function(xs: any[]){
    var sum: number, i$: number, len$: Function, x: string;
    sum = 0;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      sum += x;
    }
    return sum / xs.length;
  };
  maximum = function(xs: any[]){
    var max: number, i$: number, ref$: object, len$: Function, x: number;
    max = xs[0];
    for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (x > max) {
        max = x;
      }
    }
    return max;
  };
  minimum = function(xs: any[]){
    var min: Function, i$: number, ref$: object, len$: Function, x: Function;
    min = xs[0];
    for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (x < min) {
        min = x;
      }
    }
    return min;
  };
  maximumBy = curry$(function(f: Function, xs: any[]){
    var max: Function, i$: number, ref$: object, len$: Function, x: Function;
    max = xs[0];
    for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (f(x) > f(max)) {
        max = x;
      }
    }
    return max;
  });
  minimumBy = curry$(function(f: Function, xs: any[]){
    var min: Function, i$: number, ref$: object, len$: Function, x: Function;
    min = xs[0];
    for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (f(x) < f(min)) {
        min = x;
      }
    }
    return min;
  });
  scan = scanl = curry$(function(f: Function, memo: string, xs: Function){
    var last: string, x: string;
    last = memo;
    return [memo].concat((function(){
      var i$: number, ref$: object, len$: Function, results$: any[] = [];
      for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
        x = ref$[i$];
        results$.push(last = f(last, x));
      }
      return results$;
    }()));
  });
  scan1 = scanl1 = curry$(function(f: number, xs: any[]){
    if (!xs.length) {
      return;
    }
    return scan(f, xs[0], xs.slice(1));
  });
  scanr = curry$(function(f: number, memo: number, xs: any[]){
    xs = xs.concat().reverse();
    return scan(f, memo, xs).reverse();
  });
  scanr1 = curry$(function(f: number, xs: any[]){
    if (!xs.length) {
      return;
    }
    xs = xs.concat().reverse();
    return scan(f, xs[0], xs.slice(1)).reverse();
  });
  slice = curry$(function(x: string, y: string, xs: any[]){
    return xs.slice(x, y);
  });
  take = curry$(function(n: number, xs: any[]){
    if (n <= 0) {
      return xs.slice(0, 0);
    } else {
      return xs.slice(0, n);
    }
  });
  drop = curry$(function(n: number, xs: any[]){
    if (n <= 0) {
      return xs;
    } else {
      return xs.slice(n);
    }
  });
  splitAt = curry$(function(n: string, xs: number){
    return [take(n, xs), drop(n, xs)];
  });
  takeWhile = curry$(function(p: Function, xs: any[]){
    var len: number, i: number;
    len = xs.length;
    if (!len) {
      return xs;
    }
    i = 0;
    while (i < len && p(xs[i])) {
      i += 1;
    }
    return xs.slice(0, i);
  });
  dropWhile = curry$(function(p: Function, xs: any[]){
    var len: number, i: number;
    len = xs.length;
    if (!len) {
      return xs;
    }
    i = 0;
    while (i < len && p(xs[i])) {
      i += 1;
    }
    return xs.slice(i);
  });
  span = curry$(function(p: any[], xs: number){
    return [takeWhile(p, xs), dropWhile(p, xs)];
  });
  breakList = curry$(function(p: string, xs: any[]){
    return span(compose$(p, not$), xs);
  });
  zip = curry$(function(xs: any[], ys: any[]){
    var result: any[], len: number, i$: number, len$: Function, i: number, x: string;
    result = [];
    len = ys.length;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      i = i$;
      x = xs[i$];
      if (i === len) {
        break;
      }
      result.push([x, ys[i]]);
    }
    return result;
  });
  zipWith = curry$(function(f: Function, xs: any[], ys: any[]){
    var result: any[], len: number, i$: number, len$: Function, i: number, x: string;
    result = [];
    len = ys.length;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      i = i$;
      x = xs[i$];
      if (i === len) {
        break;
      }
      result.push(f(x, ys[i]));
    }
    return result;
  });
  zipAll = function(){
    var xss: any[], res$: any[], i$: number, to$: Function, minLength: number, len$: Function, xs: any[], ref$: Function, i: number, lresult$: any[], j$: number, results$: any[] = [];
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    xss = res$;
    minLength = undefined;
    for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
      xs = xss[i$];
      minLength <= (ref$ = xs.length) || (minLength = ref$);
    }
    for (i$ = 0; i$ < minLength; ++i$) {
      i = i$;
      lresult$ = [];
      for (j$ = 0, len$ = xss.length; j$ < len$; ++j$) {
        xs = xss[j$];
        lresult$.push(xs[i]);
      }
      results$.push(lresult$);
    }
    return results$;
  };
  zipAllWith = function(f: object){
    var xss: any[], res$: any[], i$: number, to$: Function, minLength: number, len$: Function, xs: any[], ref$: Function, i: number, results$: any[] = [];
    res$ = [];
    for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    xss = res$;
    minLength = undefined;
    for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
      xs = xss[i$];
      minLength <= (ref$ = xs.length) || (minLength = ref$);
    }
    for (i$ = 0; i$ < minLength; ++i$) {
      i = i$;
      results$.push(f.apply(null, (fn$())));
    }
    return results$;
    function fn$(): any[]{
      var i$: number, ref$: object, len$: Function, results$: any[] = [];
      for (i$ = 0, len$ = (ref$ = xss).length; i$ < len$; ++i$) {
        xs = ref$[i$];
        results$.push(xs[i]);
      }
      return results$;
    }
  };
  at = curry$(function(n: string, xs: any[]){
    if (n < 0) {
      return xs[xs.length + n];
    } else {
      return xs[n];
    }
  });
  elemIndex = curry$(function(el: string, xs: any[]){
    var i$: number, len$: Function, i: number, x: string;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      i = i$;
      x = xs[i$];
      if (x === el) {
        return i;
      }
    }
  });
  elemIndices = curry$(function(el: string, xs: any[]){
    var i$: number, len$: Function, i: number, x: string, results$: any[] = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      i = i$;
      x = xs[i$];
      if (x === el) {
        results$.push(i);
      }
    }
    return results$;
  });
  findIndex = curry$(function(f: Function, xs: any[]){
    var i$: number, len$: Function, i: number, x: string;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      i = i$;
      x = xs[i$];
      if (f(x)) {
        return i;
      }
    }
  });
  findIndices = curry$(function(f: Function, xs: any[]){
    var i$: number, len$: Function, i: number, x: string, results$: any[] = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      i = i$;
      x = xs[i$];
      if (f(x)) {
        results$.push(i);
      }
    }
    return results$;
  });

  export default {
    each: each,
    map: map,
    filter: filter,
    compact: compact,
    reject: reject,
    remove: remove,
    partition: partition,
    find: find,
    head: head,
    first: first,
    tail: tail,
    last: last,
    initial: initial,
    empty: empty,
    reverse: reverse,
    difference: difference,
    intersection: intersection,
    union: union,
    countBy: countBy,
    groupBy: groupBy,
    fold: fold,
    fold1: fold1,
    foldl: foldl,
    foldl1: foldl1,
    foldr: foldr,
    foldr1: foldr1,
    unfoldr: unfoldr,
    andList: andList,
    orList: orList,
    any: any,
    all: all,
    unique: unique,
    uniqueBy: uniqueBy,
    sort: sort,
    sortWith: sortWith,
    sortBy: sortBy,
    sum: sum,
    product: product,
    mean: mean,
    average: average,
    concat: concat,
    concatMap: concatMap,
    flatten: flatten,
    maximum: maximum,
    minimum: minimum,
    maximumBy: maximumBy,
    minimumBy: minimumBy,
    scan: scan,
    scan1: scan1,
    scanl: scanl,
    scanl1: scanl1,
    scanr: scanr,
    scanr1: scanr1,
    slice: slice,
    take: take,
    drop: drop,
    splitAt: splitAt,
    takeWhile: takeWhile,
    dropWhile: dropWhile,
    span: span,
    breakList: breakList,
    zip: zip,
    zipWith: zipWith,
    zipAll: zipAll,
    zipAllWith: zipAllWith,
    at: at,
    elemIndex: elemIndex,
    elemIndices: elemIndices,
    findIndex: findIndex,
    findIndices: findIndices
  };

  function curry$(f: any[], bound: boolean): boolean{
    var context: string,
    _curry: Function = function(args: Promise) {
      return f.length > 1 ? function(){
        var params: any[] = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
  function in$(x: string, xs: any[]): boolean{
    var i: number = -1, l: number = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
  function compose$(): Function {
    var functions: Map = arguments;
    return function() {
      var i: number, result: Function;
      result = functions[0].apply(this, arguments);
      for (i = 1; i < functions.length; ++i) {
        result = functions[i](result);
      }
      return result;
    };
  }
  function not$(x: number): boolean{ return !x; }
},{}],3:[function(require: Function,module: Function,exports: number){
  // Generated by LiveScript 1.6.0
  var max: number, min: string, negate: Function, abs: number, signum: Function, quot: any[], rem: any[], div: any[], mod: any[], recip: Function, pi: number, tau: number, exp: any[], sqrt: any[], ln: string, pow: string, sin: string, tan: any[], cos: string, asin: string, acos: any[], atan: any[], atan2: any[], truncate: Function, round: any[], ceiling: any[], floor: number, isItNaN: boolean, even: Function, odd: Function, gcd: Function, lcm: any[];
  max = curry$(function(x$: number, y$: number){
    return x$ > y$ ? x$ : y$;
  });
  min = curry$(function(x$: string, y$: number){
    return x$ < y$ ? x$ : y$;
  });
  negate = function(x: number){
    return -x;
  };
  abs = Math.abs;
  signum = function(x: number){
    if (x < 0) {
      return -1;
    } else if (x > 0) {
      return 1;
    } else {
      return 0;
    }
  };
  quot = curry$(function(x: number, y: number){
    return ~~(x / y);
  });
  rem = curry$(function(x$: number, y$: number){
    return x$ % y$;
  });
  div = curry$(function(x: number, y: number){
    return Math.floor(x / y);
  });
  mod = curry$(function(x$: number, y$: number){
    var ref$: number;
    return ((x$) % (ref$ = y$) + ref$) % ref$;
  });
  recip = (function(it: number){
    return 1 / it;
  });
  pi = Math.PI;
  tau = pi * 2;
  exp = Math.exp;
  sqrt = Math.sqrt;
  ln = Math.log;
  pow = curry$(function(x$: number, y$: number){
    return Math.pow(x$, y$);
  });
  sin = Math.sin;
  tan = Math.tan;
  cos = Math.cos;
  asin = Math.asin;
  acos = Math.acos;
  atan = Math.atan;
  atan2 = curry$(function(x: number, y: number){
    return Math.atan2(x, y);
  });
  truncate = function(x: string){
    return ~~x;
  };
  round = Math.round;
  ceiling = Math.ceil;
  floor = Math.floor;
  isItNaN = function(x: number){
    return x !== x;
  };
  even = function(x: number){
    return x % 2 === 0;
  };
  odd = function(x: number){
    return x % 2 !== 0;
  };
  gcd = curry$(function(x: number, y: number){
    var z: number;
    x = Math.abs(x);
    y = Math.abs(y);
    while (y !== 0) {
      z = x % y;
      x = y;
      y = z;
    }
    return x;
  });
  lcm = curry$(function(x: number, y: number){
    return Math.abs(Math.floor(x / gcd(x, y) * y));
  });

  export default {
    max: max,
    min: min,
    negate: negate,
    abs: abs,
    signum: signum,
    quot: quot,
    rem: rem,
    div: div,
    mod: mod,
    recip: recip,
    pi: pi,
    tau: tau,
    exp: exp,
    sqrt: sqrt,
    ln: ln,
    pow: pow,
    sin: sin,
    tan: tan,
    cos: cos,
    acos: acos,
    asin: asin,
    atan: atan,
    atan2: atan2,
    truncate: truncate,
    round: round,
    ceiling: ceiling,
    floor: floor,
    isItNaN: isItNaN,
    even: even,
    odd: odd,
    gcd: gcd,
    lcm: lcm
  };

  function curry$(f: any[], bound: boolean): boolean{
    var context: string,
    _curry: Function = function(args: Promise) {
      return f.length > 1 ? function(){
        var params: any[] = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
},{}],4:[function(require: Function,module: Function,exports: number){
  // Generated by LiveScript 1.6.0
  var values: Function, keys: Function, pairsToObj: Function, objToPairs: Function, listsToObj: any[], objToLists: Function, empty: Function, each: object, map: any[], compact: Function, filter: object, reject: object, partition: any[], find: object;
  values = function(object: object){
    var i$: string, x: string, results$: any[] = [];
    for (i$ in object) {
      x = object[i$];
      results$.push(x);
    }
    return results$;
  };
  keys = function(object: object){
    var x: string, results$: any[] = [];
    for (x in object) {
      results$.push(x);
    }
    return results$;
  };
  pairsToObj = function(object: any[]){
    var i$: number, len$: Function, x: object, resultObj$: object = {};
    for (i$ = 0, len$ = object.length; i$ < len$; ++i$) {
      x = object[i$];
      resultObj$[x[0]] = x[1];
    }
    return resultObj$;
  };
  objToPairs = function(object: object){
    var key: string, value: string, results$: any[] = [];
    for (key in object) {
      value = object[key];
      results$.push([key, value]);
    }
    return results$;
  };
  listsToObj = curry$(function(keys: any[], values: object){
    var i$: number, len$: Function, i: number, key: string, resultObj$: object = {};
    for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
      i = i$;
      key = keys[i$];
      resultObj$[key] = values[i];
    }
    return resultObj$;
  });
  objToLists = function(object: object){
    var keys: any[], values: any[], key: string, value: string;
    keys = [];
    values = [];
    for (key in object) {
      value = object[key];
      keys.push(key);
      values.push(value);
    }
    return [keys, values];
  };
  empty = function(object: object){
    var x: string;
    for (x in object) {
      return false;
    }
    return true;
  };
  each = curry$(function(f: Function, object: object){
    var i$: string, x: string;
    for (i$ in object) {
      x = object[i$];
      f(x);
    }
    return object;
  });
  map = curry$(function(f: Function, object: object){
    var k: Function, x: string, resultObj$: object = {};
    for (k in object) {
      x = object[k];
      resultObj$[k] = f(x);
    }
    return resultObj$;
  });
  compact = function(object: object){
    var k: Function, x: Function, resultObj$: object = {};
    for (k in object) {
      x = object[k];
      if (x) {
        resultObj$[k] = x;
      }
    }
    return resultObj$;
  };
  filter = curry$(function(f: Function, object: object){
    var k: Function, x: string, resultObj$: object = {};
    for (k in object) {
      x = object[k];
      if (f(x)) {
        resultObj$[k] = x;
      }
    }
    return resultObj$;
  });
  reject = curry$(function(f: Function, object: object){
    var k: Function, x: string, resultObj$: object = {};
    for (k in object) {
      x = object[k];
      if (!f(x)) {
        resultObj$[k] = x;
      }
    }
    return resultObj$;
  });
  partition = curry$(function(f: Function, object: object){
    var passed: object, failed: object, k: Function, x: string;
    passed = {};
    failed = {};
    for (k in object) {
      x = object[k];
      (f(x) ? passed : failed)[k] = x;
    }
    return [passed, failed];
  });
  find = curry$(function(f: Function, object: object){
    var i$: string, x: string;
    for (i$ in object) {
      x = object[i$];
      if (f(x)) {
        return x;
      }
    }
  });

  export default {
    values: values,
    keys: keys,
    pairsToObj: pairsToObj,
    objToPairs: objToPairs,
    listsToObj: listsToObj,
    objToLists: objToLists,
    empty: empty,
    each: each,
    map: map,
    filter: filter,
    compact: compact,
    reject: reject,
    partition: partition,
    find: find
  };

  function curry$(f: any[], bound: boolean): boolean{
    var context: string,
    _curry: Function = function(args: Promise) {
      return f.length > 1 ? function(){
        var params: any[] = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
},{}],5:[function(require: Function,module: Function,exports: number){
  // Generated by LiveScript 1.6.0
  var split: object, join: string, lines: Function, unlines: Function, words: Function, unwords: Function, chars: Function, unchars: Function, reverse: Function, repeat: string, capitalize: Function, camelize: Function, dasherize: Function;
  split = curry$(function(sep: any[], str: string){
    return str.split(sep);
  });
  join = curry$(function(sep: string, xs: object){
    return xs.join(sep);
  });
  lines = function(str: string){
    if (!str.length) {
      return [];
    }
    return str.split('\n');
  };
  unlines = function(it: object){
    return it.join('\n');
  };
  words = function(str: string){
    if (!str.length) {
      return [];
    }
    return str.split(/[ ]+/);
  };
  unwords = function(it: object){
    return it.join(' ');
  };
  chars = function(it: string){
    return it.split('');
  };
  unchars = function(it: object){
    return it.join('');
  };
  reverse = function(str: string){
    return str.split('').reverse().join('');
  };
  repeat = curry$(function(n: number, str: string){
    var result: string, i$: number;
    result = '';
    for (i$ = 0; i$ < n; ++i$) {
      result += str;
    }
    return result;
  });
  capitalize = function(str: string){
    return str.charAt(0).toUpperCase() + str.slice(1);
  };
  camelize = function(it: string){
    return it.replace(/[-_]+(.)?/g, function(arg$: Function, c: string){
      return (c != null ? c : '').toUpperCase();
    });
  };
  dasherize = function(str: string){
    return str.replace(/([^-A-Z])([A-Z]+)/g, function(arg$: Function, lower: number, upper: string){
      return lower + "-" + (upper.length > 1
        ? upper
        : upper.toLowerCase());
    }).replace(/^([A-Z]+)/, function(arg$: number, upper: string){
      if (upper.length > 1) {
        return upper + "-";
      } else {
        return upper.toLowerCase();
      }
    });
  };

  export default {
    split: split,
    join: join,
    lines: lines,
    unlines: unlines,
    words: words,
    unwords: unwords,
    chars: chars,
    unchars: unchars,
    reverse: reverse,
    repeat: repeat,
    capitalize: capitalize,
    camelize: camelize,
    dasherize: dasherize
  };

  function curry$(f: any[], bound: boolean): boolean{
    var context: string,
    _curry: Function = function(args: Promise) {
      return f.length > 1 ? function(){
        var params: any[] = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
},{}],"prelude-ls":[function(require: Function,module: Function,exports: number){
  // Generated by LiveScript 1.6.0
  var Func: object, List: object, Obj: object, Str: object, Num: object, id: Function, isType: string, replicate: string, prelude: object, toString$: Function = {}.toString;
  Func = require('./Func.js');
  List = require('./List.js');
  Obj = require('./Obj.js');
  Str = require('./Str.js');
  Num = require('./Num.js');
  id = function(x: string){
    return x;
  };
  isType = curry$(function(type: number, x: string){
    return toString$.call(x).slice(8, -1) === type;
  });
  replicate = curry$(function(n: number, x: string){
    var i$: number, results$: any[] = [];
    for (i$ = 0; i$ < n; ++i$) {
      results$.push(x);
    }
    return results$;
  });
  Str.empty = List.empty;
  Str.slice = List.slice;
  Str.take = List.take;
  Str.drop = List.drop;
  Str.splitAt = List.splitAt;
  Str.takeWhile = List.takeWhile;
  Str.dropWhile = List.dropWhile;
  Str.span = List.span;
  Str.breakStr = List.breakList;
  prelude = {
    Func: Func,
    List: List,
    Obj: Obj,
    Str: Str,
    Num: Num,
    id: id,
    isType: isType,
    replicate: replicate
  };
  prelude.each = List.each;
  prelude.map = List.map;
  prelude.filter = List.filter;
  prelude.compact = List.compact;
  prelude.reject = List.reject;
  prelude.partition = List.partition;
  prelude.find = List.find;
  prelude.head = List.head;
  prelude.first = List.first;
  prelude.tail = List.tail;
  prelude.last = List.last;
  prelude.initial = List.initial;
  prelude.empty = List.empty;
  prelude.reverse = List.reverse;
  prelude.difference = List.difference;
  prelude.intersection = List.intersection;
  prelude.union = List.union;
  prelude.countBy = List.countBy;
  prelude.groupBy = List.groupBy;
  prelude.fold = List.fold;
  prelude.foldl = List.foldl;
  prelude.fold1 = List.fold1;
  prelude.foldl1 = List.foldl1;
  prelude.foldr = List.foldr;
  prelude.foldr1 = List.foldr1;
  prelude.unfoldr = List.unfoldr;
  prelude.andList = List.andList;
  prelude.orList = List.orList;
  prelude.any = List.any;
  prelude.all = List.all;
  prelude.unique = List.unique;
  prelude.uniqueBy = List.uniqueBy;
  prelude.sort = List.sort;
  prelude.sortWith = List.sortWith;
  prelude.sortBy = List.sortBy;
  prelude.sum = List.sum;
  prelude.product = List.product;
  prelude.mean = List.mean;
  prelude.average = List.average;
  prelude.concat = List.concat;
  prelude.concatMap = List.concatMap;
  prelude.flatten = List.flatten;
  prelude.maximum = List.maximum;
  prelude.minimum = List.minimum;
  prelude.maximumBy = List.maximumBy;
  prelude.minimumBy = List.minimumBy;
  prelude.scan = List.scan;
  prelude.scanl = List.scanl;
  prelude.scan1 = List.scan1;
  prelude.scanl1 = List.scanl1;
  prelude.scanr = List.scanr;
  prelude.scanr1 = List.scanr1;
  prelude.slice = List.slice;
  prelude.take = List.take;
  prelude.drop = List.drop;
  prelude.splitAt = List.splitAt;
  prelude.takeWhile = List.takeWhile;
  prelude.dropWhile = List.dropWhile;
  prelude.span = List.span;
  prelude.breakList = List.breakList;
  prelude.zip = List.zip;
  prelude.zipWith = List.zipWith;
  prelude.zipAll = List.zipAll;
  prelude.zipAllWith = List.zipAllWith;
  prelude.at = List.at;
  prelude.elemIndex = List.elemIndex;
  prelude.elemIndices = List.elemIndices;
  prelude.findIndex = List.findIndex;
  prelude.findIndices = List.findIndices;
  prelude.apply = Func.apply;
  prelude.curry = Func.curry;
  prelude.flip = Func.flip;
  prelude.fix = Func.fix;
  prelude.over = Func.over;
  prelude.split = Str.split;
  prelude.join = Str.join;
  prelude.lines = Str.lines;
  prelude.unlines = Str.unlines;
  prelude.words = Str.words;
  prelude.unwords = Str.unwords;
  prelude.chars = Str.chars;
  prelude.unchars = Str.unchars;
  prelude.repeat = Str.repeat;
  prelude.capitalize = Str.capitalize;
  prelude.camelize = Str.camelize;
  prelude.dasherize = Str.dasherize;
  prelude.values = Obj.values;
  prelude.keys = Obj.keys;
  prelude.pairsToObj = Obj.pairsToObj;
  prelude.objToPairs = Obj.objToPairs;
  prelude.listsToObj = Obj.listsToObj;
  prelude.objToLists = Obj.objToLists;
  prelude.max = Num.max;
  prelude.min = Num.min;
  prelude.negate = Num.negate;
  prelude.abs = Num.abs;
  prelude.signum = Num.signum;
  prelude.quot = Num.quot;
  prelude.rem = Num.rem;
  prelude.div = Num.div;
  prelude.mod = Num.mod;
  prelude.recip = Num.recip;
  prelude.pi = Num.pi;
  prelude.tau = Num.tau;
  prelude.exp = Num.exp;
  prelude.sqrt = Num.sqrt;
  prelude.ln = Num.ln;
  prelude.pow = Num.pow;
  prelude.sin = Num.sin;
  prelude.tan = Num.tan;
  prelude.cos = Num.cos;
  prelude.acos = Num.acos;
  prelude.asin = Num.asin;
  prelude.atan = Num.atan;
  prelude.atan2 = Num.atan2;
  prelude.truncate = Num.truncate;
  prelude.round = Num.round;
  prelude.ceiling = Num.ceiling;
  prelude.floor = Num.floor;
  prelude.isItNaN = Num.isItNaN;
  prelude.even = Num.even;
  prelude.odd = Num.odd;
  prelude.gcd = Num.gcd;
  prelude.lcm = Num.lcm;
  prelude.VERSION = '1.2.1';
  export default prelude;
  function curry$(f: any[], bound: boolean): boolean{
    var context: string,
    _curry: Function = function(args: Promise) {
      return f.length > 1 ? function(){
        var params: any[] = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
},{"./Func.js":1,"./List.js":2,"./Num.js":3,"./Obj.js":4,"./Str.js":5}]},{},[]);
