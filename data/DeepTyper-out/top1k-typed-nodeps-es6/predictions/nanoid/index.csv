importKeyword
 Text.Whitespace
{Punctuation
 Text.Whitespace
randomFillSyncName.Otherany0.4878number0.1208string0.0535complex0.0356boolean0.0324
 Text.Whitespace
}Punctuation
 Text.Whitespace
fromKeyword.Reserved
 Text.Whitespace
'crypto'Literal.String.Single
\n\nText.Whitespace
importKeyword
 Text.Whitespace
{Punctuation
 Text.Whitespace
urlAlphabetName.Otherany0.5238number0.0969string0.0734complex0.0505void0.0215
 Text.Whitespace
}Punctuation
 Text.Whitespace
fromKeyword.Reserved
 Text.Whitespace
'./url-alphabet/index.js'Literal.String.Single
\n\nText.Whitespace
exportKeyword
 Text.Whitespace
{Punctuation
 Text.Whitespace
urlAlphabetName.Othernumber0.4531any0.2050string0.1699void0.0382boolean0.0152
 Text.Whitespace
}Punctuation
\n\nText.Whitespace
Text
// It is best to make fewer, larger requests to the crypto module toComment.Single
\nText.Whitespace
// avoid system call overhead. So, random numbers are generated in aComment.Single
\nText.Whitespace
// pool. The pool is a Buffer that is larger than the initial randomComment.Single
\nText.Whitespace
// request size by this multiplier. The pool is enlarged if subsequentComment.Single
\nText.Whitespace
// requests exceed the maximum buffer size.Comment.Single
\nText.Whitespace
constKeyword.Declaration
 Text.Whitespace
POOL_SIZE_MULTIPLIERName.Othernumber0.8944string0.0346any0.0270void0.0069complex0.0058
 Text.Whitespace
=Operator
 Text.Whitespace
128Literal.Number.Float
\nText.Whitespace
letKeyword.Declaration
 Text.Whitespace
poolName.Otherany0.3736string0.0469complex0.0461number0.0275void0.0131
,Punctuation
 Text.Whitespace
poolOffsetName.Othernumber0.5992any0.1951string0.0519void0.0315complex0.0080
\n\nText.Whitespace
letKeyword.Declaration
 Text.Whitespace
fillPoolName.Othernumber0.7851any0.1036string0.0535void0.0072complex0.0050
 Text.Whitespace
=Operator
 Text.Whitespace
bytesName.Otherany0.5838number0.2765string0.0185complex0.0078any[]0.0061
 Text.Whitespace
=>Punctuation
 Text.Whitespace
{Punctuation
\n  Text.Whitespace
ifKeyword
 Text.Whitespace
(Punctuation
!Operator
poolName.Otherany0.4182complex0.0851any[]0.0357string0.0271number0.0259
 Text.Whitespace
||Operator
 Text.Whitespace
poolName.Otherany0.2184complex0.1586any[]0.1044string[]0.0580T[]0.0219
.Punctuation
lengthName.Othernumber0.9850any0.0128string0.0007void0.0004complex0.0004
 Text.Whitespace
<Operator
 Text.Whitespace
bytesName.Othernumber0.6419any0.3446string0.0045complex0.0027number[]0.0008
)Punctuation
 Text.Whitespace
{Punctuation
\n    Text.Whitespace
poolName.Otherany0.9255complex0.0167number0.0114void0.0070string0.0053
 Text.Whitespace
=Operator
 Text.Whitespace
BufferName.Otherany0.9855Buffer0.0022number0.0016void0.0007complex0.0006
.Punctuation
allocUnsafeName.Otherany0.5827number0.3585string0.0216void0.0115boolean0.0086
(Punctuation
bytesName.Othernumber0.6681any0.3121string0.0142complex0.0023number[]0.0004
 Text.Whitespace
*Operator
 Text.Whitespace
POOL_SIZE_MULTIPLIERName.Othernumber0.9899any0.0049string0.0034complex0.0004void0.0003
)Punctuation
\n    Text.Whitespace
randomFillSyncName.Othervoid0.4551number0.4505any0.0358string0.0156complex0.0123
(Punctuation
poolName.Otherany0.7179complex0.0544number0.0176string0.0140any[]0.0137
)Punctuation
\n    Text.Whitespace
poolOffsetName.Othernumber0.9868any0.0096string0.0021void0.0005boolean0.0002
 Text.Whitespace
=Operator
 Text.Whitespace
0Literal.Number.Float
\n  Text.Whitespace
}Punctuation
 Text.Whitespace
elseKeyword
 Text.Whitespace
ifKeyword
 Text.Whitespace
(Punctuation
poolOffsetName.Othernumber0.9350any0.0537string0.0067boolean0.0025complex0.0007
 Text.Whitespace
+Operator
 Text.Whitespace
bytesName.Othernumber0.6416any0.3476string0.0080complex0.0011void0.0004
 Text.Whitespace
>Operator
 Text.Whitespace
poolName.Otherany0.3221string[]0.1177complex0.1089any[]0.0999number[]0.0402
.Punctuation
lengthName.Othernumber0.9924any0.0064string0.0006void0.0002boolean0.0001
)Punctuation
 Text.Whitespace
{Punctuation
\n    Text.Whitespace
randomFillSyncName.Othervoid0.6178number0.2357any0.0672complex0.0164string0.0157
(Punctuation
poolName.Otherany0.6574complex0.0906any[]0.0167string0.0163number0.0138
)Punctuation
\n    Text.Whitespace
poolOffsetName.Othernumber0.9896any0.0072string0.0023void0.0002boolean0.0001
 Text.Whitespace
=Operator
 Text.Whitespace
0Literal.Number.Float
\n  Text.Whitespace
}Punctuation
\n  Text.Whitespace
poolOffsetName.Othernumber0.9544string0.0293any0.0103void0.0019boolean0.0008
 Text.Whitespace
+=Operator
 Text.Whitespace
bytesName.Othernumber0.7915any0.1783string0.0153complex0.0029number[]0.0020
\nText.Whitespace
}Punctuation
\n\nText.Whitespace
exportKeyword
 Text.Whitespace
letKeyword.Declaration
 Text.Whitespace
randomName.Othernumber0.8181any0.1105string0.0123void0.0057Function0.0028
 Text.Whitespace
=Operator
 Text.Whitespace
bytesName.Othernumber0.5250any0.1969string0.0175Uint8Array0.0080Buffer0.0055
 Text.Whitespace
=>Punctuation
 Text.Whitespace
{Punctuation
\n  Text.Whitespace
// `-=` convert `bytes` to number to prevent `valueOf` abusingComment.Single
\n  Text.Whitespace
fillPoolName.Othernumber0.6899any0.0777void0.0334complex0.0261string0.0235
(Punctuation
(Punctuation
bytesName.Othernumber0.7948any0.1891string0.0050complex0.0015number[]0.0006
 Text.Whitespace
-=Operator
 Text.Whitespace
0Literal.Number.Float
)Punctuation
)Punctuation
\n  Text.Whitespace
returnKeyword
 Text.Whitespace
poolName.Otherany0.3880complex0.0533Pool0.0121number0.0068A0.0048
.Punctuation
subarrayName.OtherT[]0.1136Promise<any>0.0604number0.0444complex0.0280Promise<void>0.0231
(Punctuation
poolOffsetName.Othernumber0.9929any0.0054string0.0009complex0.0002boolean0.0001
 Text.Whitespace
-Operator
 Text.Whitespace
bytesName.Othernumber0.8573any0.1060number[]0.0069complex0.0055string0.0049
,Punctuation
 Text.Whitespace
poolOffsetName.Othernumber0.9785any0.0080void0.0050string0.0022complex0.0015
)Punctuation
\nText.Whitespace
}Punctuation
\n\nText.Whitespace
exportKeyword
 Text.Whitespace
letKeyword.Declaration
 Text.Whitespace
customRandomName.Othernumber0.9533any0.0140string0.0114void0.0083boolean0.0055
 Text.Whitespace
=Operator
 Text.Whitespace
(Punctuation
alphabetName.Othernumber0.9244any0.0286string0.0251boolean0.0031Function0.0008
,Punctuation
 Text.Whitespace
defaultSizeName.Othernumber0.9581string0.0177any0.0147boolean0.0026number[]0.0003
,Punctuation
 Text.Whitespace
getRandomName.Othernumber0.9482string0.0218any0.0165boolean0.0044complex0.0005
)Punctuation
 Text.Whitespace
=>Punctuation
 Text.Whitespace
{Punctuation
\n  Text.Whitespace
// First, a bitmask is necessary to generate the ID. The bitmask makes bytesComment.Single
\n  Text.Whitespace
// values closer to the alphabet size. The bitmask calculates the closestComment.Single
\n  Text.Whitespace
// `2^31 - 1` number, which exceeds the alphabet size.Comment.Single
\n  Text.Whitespace
// For example, the bitmask for the alphabet size 30 is 31 (00011111).Comment.Single
\n  Text.Whitespace
letKeyword.Declaration
 Text.Whitespace
maskName.Othernumber0.9764string0.0110any0.0088boolean0.0024void0.0005
 Text.Whitespace
=Operator
 Text.Whitespace
(Punctuation
2Literal.Number.Float
 Text.Whitespace
<<Operator
 Text.Whitespace
(Punctuation
31Literal.Number.Float
 Text.Whitespace
-Operator
 Text.Whitespace
MathName.BuiltinMath0.9999number0.0000ArrayConstructor0.0000ClientRect0.0000any0.0000
.Punctuation
clz32Name.Othernumber0.9789string0.0033complex0.0032any0.0024number[]0.0021
(Punctuation
(Punctuation
alphabetName.Othernumber0.2713string[]0.2356any0.1905number[]0.1419string0.0534
.Punctuation
lengthName.Othernumber0.9906any0.0086string0.0004complex0.0001void0.0001
 Text.Whitespace
-Operator
 Text.Whitespace
1Literal.Number.Float
)Punctuation
 Text.Whitespace
|Operator
 Text.Whitespace
1Literal.Number.Float
)Punctuation
)Punctuation
)Punctuation
 Text.Whitespace
-Operator
 Text.Whitespace
1Literal.Number.Float
\n  Text.Whitespace
// Though, the bitmask solution is not perfect since the bytes exceedingComment.Single
\n  Text.Whitespace
// the alphabet size are refused. Therefore, to reliably generate the ID,Comment.Single
\n  Text.Whitespace
// the random bytes redundancy has to be satisfied.Comment.Single
\n\n  Text.Whitespace
// Note: every hardware random generator call is performance expensive,Comment.Single
\n  Text.Whitespace
// because the system call for entropy collection takes a lot of time.Comment.Single
\n  Text.Whitespace
// So, to avoid additional system calls, extra bytes are requested in advance.Comment.Single
\n\n  Text.Whitespace
// Next, a step determines how many random bytes to generate.Comment.Single
\n  Text.Whitespace
// The number of random bytes gets decided upon the ID size, mask,Comment.Single
\n  Text.Whitespace
// alphabet size, and magic number 1.6 (using 1.6 peaks at performanceComment.Single
\n  Text.Whitespace
// according to benchmarks).Comment.Single
\n  Text.Whitespace
letKeyword.Declaration
 Text.Whitespace
stepName.Othernumber0.9961any0.0022string0.0009boolean0.0003void0.0001
 Text.Whitespace
=Operator
 Text.Whitespace
MathName.BuiltinMath0.9999PointerCoordinates0.0000number0.0000ArrayConstructor0.0000ClientRect0.0000
.Punctuation
ceilName.Othernumber0.9979any0.0005string0.0004complex0.0003boolean0.0002
(Punctuation
(Punctuation
1.6Literal.Number.Float
 Text.Whitespace
*Operator
 Text.Whitespace
maskName.Othernumber0.9779any0.0183string0.0030void0.0002boolean0.0002
 Text.Whitespace
*Operator
 Text.Whitespace
defaultSizeName.Othernumber0.9925any0.0032string0.0031boolean0.0003complex0.0002
)Punctuation
 Text.Whitespace
/Operator
 Text.Whitespace
alphabetName.Othernumber0.6581string0.1152any0.1052number[]0.0328string[]0.0326
.Punctuation
lengthName.Othernumber0.9943any0.0046string0.0007void0.0001boolean0.0001
)Punctuation
\n\n  Text.Whitespace
returnKeyword
 Text.Whitespace
(Punctuation
sizeName.Othernumber0.9506any0.0285string0.0190boolean0.0005complex0.0004
 Text.Whitespace
=Operator
 Text.Whitespace
defaultSizeName.Othernumber0.9598string0.0212any0.0141boolean0.0019void0.0006
)Punctuation
 Text.Whitespace
=>Punctuation
 Text.Whitespace
{Punctuation
\n    Text.Whitespace
letKeyword.Declaration
 Text.Whitespace
idName.Otherstring0.9057any0.0473number0.0425complex0.0017boolean0.0011
 Text.Whitespace
=Operator
 Text.Whitespace
''Literal.String.Single
\n    Text.Whitespace
whileKeyword
 Text.Whitespace
(Punctuation
trueKeyword.Constant
)Punctuation
 Text.Whitespace
{Punctuation
\n      Text.Whitespace
letKeyword.Declaration
 Text.Whitespace
bytesName.Othernumber0.7628any0.1764string0.0281complex0.0083number[]0.0083
 Text.Whitespace
=Operator
 Text.Whitespace
getRandomName.Othernumber0.9551any0.0183string0.0123complex0.0055boolean0.0022
(Punctuation
stepName.Othernumber0.9776any0.0138string0.0028complex0.0015void0.0014
)Punctuation
\n      Text.Whitespace
// A compact alternative for `for (let i = 0; i < step; i++)`.Comment.Single
\n      Text.Whitespace
letKeyword.Declaration
 Text.Whitespace
iName.Othernumber0.9917any0.0068string0.0007boolean0.0004complex0.0001
 Text.Whitespace
=Operator
 Text.Whitespace
stepName.Othernumber0.9842any0.0105string0.0030void0.0007boolean0.0006
\n      Text.Whitespace
whileKeyword
 Text.Whitespace
(Punctuation
iName.Othernumber0.9883any0.0105string0.0004boolean0.0004complex0.0001
--Operator
)Punctuation
 Text.Whitespace
{Punctuation
\n        Text.Whitespace
// Adding `|| ''` refuses a random byte that exceeds the alphabet size.Comment.Single
\n        Text.Whitespace
idName.Otherstring0.6604number0.2818any0.0536complex0.0016boolean0.0007
 Text.Whitespace
+=Operator
 Text.Whitespace
alphabetName.Othernumber0.3789any0.2057complex0.1935string0.0980number[]0.0208
[Punctuation
bytesName.Otherany0.2341number0.2294number[]0.1876string[]0.0513complex0.0431
[Punctuation
iName.Othernumber0.9942any0.0031string0.0023boolean0.0001complex0.0001
]Punctuation
 Text.Whitespace
&Operator
 Text.Whitespace
maskName.Othernumber0.8376any0.1062string0.0491void0.0006boolean0.0004
]Punctuation
 Text.Whitespace
||Operator
 Text.Whitespace
''Literal.String.Single
\n        Text.Whitespace
ifKeyword
 Text.Whitespace
(Punctuation
idName.Otherstring0.8637any0.0767number0.0386string[]0.0090complex0.0038
.Punctuation
lengthName.Othernumber0.9881any0.0101string0.0012complex0.0002void0.0001
 Text.Whitespace
===Operator
 Text.Whitespace
sizeName.Othernumber0.9772any0.0115string0.0096complex0.0008boolean0.0002
)Punctuation
 Text.Whitespace
returnKeyword
 Text.Whitespace
idName.Otherstring0.5719number0.3428any0.0750complex0.0020boolean0.0011
\n      Text.Whitespace
}Punctuation
\n    Text.Whitespace
}Punctuation
\n  Text.Whitespace
}Punctuation
\nText.Whitespace
}Punctuation
\n\nText.Whitespace
exportKeyword
 Text.Whitespace
letKeyword.Declaration
 Text.Whitespace
customAlphabetName.Othernumber0.8825any0.0642string0.0291complex0.0050boolean0.0025
 Text.Whitespace
=Operator
 Text.Whitespace
(Punctuation
alphabetName.Othernumber0.8989any0.0460string0.0438complex0.0012boolean0.0011
,Punctuation
 Text.Whitespace
sizeName.Othernumber0.9891any0.0071string0.0033boolean0.0001complex0.0001
 Text.Whitespace
=Operator
 Text.Whitespace
21Literal.Number.Float
)Punctuation
 Text.Whitespace
=>Punctuation
\n  Text.Whitespace
customRandomName.Othernumber0.8076any0.0553string0.0326void0.0309complex0.0123
(Punctuation
alphabetName.Othernumber0.9292string0.0407any0.0249boolean0.0014complex0.0005
,Punctuation
 Text.Whitespace
sizeName.Othernumber0.9734any0.0169string0.0086complex0.0003boolean0.0001
,Punctuation
 Text.Whitespace
randomName.Othernumber0.9440any0.0505string0.0032boolean0.0005void0.0004
)Punctuation
\n\nText.Whitespace
exportKeyword
 Text.Whitespace
letKeyword.Declaration
 Text.Whitespace
nanoidName.Othernumber0.9738string0.0104any0.0095boolean0.0019void0.0008
 Text.Whitespace
=Operator
 Text.Whitespace
(Punctuation
sizeName.Othernumber0.9910any0.0044string0.0040boolean0.0002complex0.0001
 Text.Whitespace
=Operator
 Text.Whitespace
21Literal.Number.Float
)Punctuation
 Text.Whitespace
=>Punctuation
 Text.Whitespace
{Punctuation
\n  Text.Whitespace
// `-=` convert `size` to number to prevent `valueOf` abusingComment.Single
\n  Text.Whitespace
fillPoolName.Othernumber0.7691string0.1714any0.0335boolean0.0104void0.0064
(Punctuation
(Punctuation
sizeName.Othernumber0.8992any0.0869string0.0109complex0.0011boolean0.0003
 Text.Whitespace
-=Operator
 Text.Whitespace
0Literal.Number.Float
)Punctuation
)Punctuation
\n  Text.Whitespace
letKeyword.Declaration
 Text.Whitespace
idName.Otherstring0.9692any0.0178number0.0090complex0.0011string[]0.0008
 Text.Whitespace
=Operator
 Text.Whitespace
''Literal.String.Single
\n  Text.Whitespace
// We are reading directly from the random pool to avoid creating new arrayComment.Single
\n  Text.Whitespace
forKeyword
 Text.Whitespace
(Punctuation
letKeyword.Declaration
 Text.Whitespace
iName.Othernumber0.9961any0.0025string0.0010boolean0.0002complex0.0001
 Text.Whitespace
=Operator
 Text.Whitespace
poolOffsetName.Othernumber0.9921any0.0048string0.0025complex0.0002boolean0.0001
 Text.Whitespace
-Operator
 Text.Whitespace
sizeName.Othernumber0.9826any0.0105string0.0058complex0.0006boolean0.0002
;Punctuation
 Text.Whitespace
iName.Othernumber0.9930any0.0054string0.0009boolean0.0002complex0.0002
 Text.Whitespace
<Operator
 Text.Whitespace
poolOffsetName.Othernumber0.9919any0.0043string0.0030boolean0.0004complex0.0002
;Punctuation
 Text.Whitespace
iName.Othernumber0.9949any0.0042string0.0005boolean0.0002complex0.0001
++Operator
)Punctuation
 Text.Whitespace
{Punctuation
\n    Text.Whitespace
// It is incorrect to use bytes exceeding the alphabet size.Comment.Single
\n    Text.Whitespace
// The following mask reduces the random byte in the 0-255 valueComment.Single
\n    Text.Whitespace
// range to the 0-63 value range. Therefore, adding hacks, suchComment.Single
\n    Text.Whitespace
// as empty string fallback or magic numbers, is unneccessary becauseComment.Single
\n    Text.Whitespace
// the bitmask trims bytes down to the alphabet size.Comment.Single
\n    Text.Whitespace
idName.Otherstring0.7960number0.1639any0.0373complex0.0010boolean0.0006
 Text.Whitespace
+=Operator
 Text.Whitespace
urlAlphabetName.Otherany0.3115number0.2770complex0.1666string0.0797string[]0.0339
[Punctuation
poolName.Otherany0.1595complex0.1241string[]0.1195any[]0.1132number[]0.0582
[Punctuation
iName.Othernumber0.9924string0.0043any0.0028boolean0.0002complex0.0000
]Punctuation
 Text.Whitespace
&Operator
 Text.Whitespace
63Literal.Number.Float
]Punctuation
\n  Text.Whitespace
}Punctuation
\n  Text.Whitespace
returnKeyword
 Text.Whitespace
idName.Otherstring0.7003number0.1730any0.1103complex0.0069boolean0.0009
\nText.Whitespace
}Punctuation
\nText.Whitespace
