export default index;
export const __esModule: boolean;
declare namespace index {
    export { apply };
    export { applyEach };
    export { applyEachSeries };
    export { asyncify };
    export { auto };
    export { autoInject };
    export { cargo };
    export { compose };
    export { concat };
    export { concatLimit };
    export { concatSeries };
    export { constant };
    export { detect };
    export { detectLimit };
    export { detectSeries };
    export { dir };
    export { doDuring };
    export { doUntil };
    export { doWhilst };
    export { during };
    export { eachLimit as each };
    export { eachLimit$1 as eachLimit };
    export { eachOf };
    export { eachOfLimit };
    export { eachOfSeries };
    export { eachSeries };
    export { ensureAsync };
    export { every };
    export { everyLimit };
    export { everySeries };
    export { filter };
    export { filterLimit };
    export { filterSeries };
    export { forever };
    export { groupBy };
    export { groupByLimit };
    export { groupBySeries };
    export { log };
    export { map };
    export { mapLimit };
    export { mapSeries };
    export { mapValues };
    export { mapValuesLimit };
    export { mapValuesSeries };
    export { memoize };
    export { nextTick };
    export { parallelLimit as parallel };
    export { parallelLimit$1 as parallelLimit };
    export { priorityQueue };
    export { queue$1 as queue };
    export { race };
    export { reduce };
    export { reduceRight };
    export { reflect };
    export { reflectAll };
    export { reject };
    export { rejectLimit };
    export { rejectSeries };
    export { retry };
    export { retryable };
    export { seq };
    export { series };
    export { setImmediate$1 as setImmediate };
    export { some };
    export { someLimit };
    export { someSeries };
    export { sortBy };
    export { timeout };
    export { times };
    export { timeLimit as timesLimit };
    export { timesSeries };
    export { transform };
    export { tryEach };
    export { unmemoize };
    export { until };
    export { waterfall };
    export { whilst };
    export { every as all };
    export { everyLimit as allLimit };
    export { everySeries as allSeries };
    export { some as any };
    export { someLimit as anyLimit };
    export { someSeries as anySeries };
    export { detect as find };
    export { detectLimit as findLimit };
    export { detectSeries as findSeries };
    export { eachLimit as forEach };
    export { eachSeries as forEachSeries };
    export { eachLimit$1 as forEachLimit };
    export { eachOf as forEachOf };
    export { eachOfSeries as forEachOfSeries };
    export { eachOfLimit as forEachOfLimit };
    export { reduce as inject };
    export { reduce as foldl };
    export { reduceRight as foldr };
    export { filter as select };
    export { filterLimit as selectLimit };
    export { filterSeries as selectSeries };
    export { asyncify as wrapSync };
}
export function apply(fn: Function, ...args: any[]): Function;
export function applyEach(fns: any, ...args: any[]): any;
export function applyEachSeries(fns: any, ...args: any[]): any;
export function asyncify(func: Function): Function;
export function auto(tasks: any, concurrency?: number, callback?: Function): any;
export function autoInject(tasks: any, callback?: Function): void;
export function cargo(worker: Function, payload?: number): any;
export function compose(...args: Function[]): Function;
export function concat(iterable: any, iteratee: any, callback: any): any;
export function concatLimit(coll: any[] | Iterable<any> | any, limit: number, iteratee: Function, callback?: Function): void;
export function concatSeries(iterable: any, iteratee: any, callback: any): any;
export function constant(...args: any[]): Function;
export function detect(obj: any, iteratee: any, callback: any): any;
export function detectLimit(obj: any, limit: any, iteratee: any, callback: any): any;
export function detectSeries(iterable: any, iteratee: any, callback: any): any;
export function dir(fn: any, ...args: any[]): void;
export function doDuring(fn: Function, test: Function, callback?: Function): void;
export function doUntil(iteratee: Function, test: Function, callback?: Function): void;
export function doWhilst(iteratee: Function, test: Function, callback?: Function): void;
export function during(test: Function, fn: Function, callback?: Function): void;
declare function eachLimit(coll: any[] | Iterable<any> | any, iteratee: Function, callback?: Function): void;
declare function eachLimit$1(coll: any[] | Iterable<any> | any, limit: number, iteratee: Function, callback?: Function): void;
export function eachOf(coll: any[] | Iterable<any> | any, iteratee: Function, callback?: Function): void;
export function eachOfLimit(coll: any[] | Iterable<any> | any, limit: number, iteratee: Function, callback?: Function): void;
export function eachOfSeries(iterable: any, iteratee: any, callback: any): any;
export function eachSeries(iterable: any, iteratee: any, callback: any): any;
export function ensureAsync(fn: Function): Function;
export function every(obj: any, iteratee: any, callback: any): any;
export function everyLimit(obj: any, limit: any, iteratee: any, callback: any): any;
export function everySeries(iterable: any, iteratee: any, callback: any): any;
export function filter(obj: any, iteratee: any, callback: any): any;
export function filterLimit(obj: any, limit: any, iteratee: any, callback: any): any;
export function filterSeries(iterable: any, iteratee: any, callback: any): any;
export function forever(fn: Function, errback?: Function): void;
export function groupBy(iterable: any, iteratee: any, callback: any): any;
export function groupByLimit(coll: any[] | Iterable<any> | any, limit: number, iteratee: Function, callback?: Function): void;
export function groupBySeries(iterable: any, iteratee: any, callback: any): any;
export function log(fn: any, ...args: any[]): void;
export function map(obj: any, iteratee: any, callback: any): any;
export function mapLimit(obj: any, limit: any, iteratee: any, callback: any): any;
export function mapSeries(iterable: any, iteratee: any, callback: any): any;
export function mapValues(iterable: any, iteratee: any, callback: any): any;
export function mapValuesLimit(obj: any, limit: number, iteratee: Function, callback?: Function): void;
export function mapValuesSeries(iterable: any, iteratee: any, callback: any): any;
export function memoize(fn: Function, hasher: Function): Function;
export function nextTick(fn: any, ...args: any[]): void;
declare function parallelLimit(tasks: any[] | Iterable<any> | any, callback?: Function): void;
declare function parallelLimit$1(tasks: any[] | Iterable<any> | any, limit: number, callback?: Function): void;
export function priorityQueue(worker: Function, concurrency: number): any;
declare function queue$1(worker: Function, concurrency?: number): any;
export function race(tasks: any[], callback: Function): any;
export function reduce(coll: any[] | Iterable<any> | any, memo: any, iteratee: Function, callback?: Function): void;
export function reduceRight(array: any[], memo: any, iteratee: Function, callback?: Function): void;
export function reflect(fn: Function): Function;
export function reflectAll(tasks: any[] | any | Iterable<any>): any[];
export function reject(obj: any, iteratee: any, callback: any): any;
export function rejectLimit(obj: any, limit: any, iteratee: any, callback: any): any;
export function rejectSeries(iterable: any, iteratee: any, callback: any): any;
export function retry(opts?: any | number, task: Function, callback?: Function, ...args: any[]): void;
export function retryable(opts?: any | number, task: Function): Function;
export function seq(...args: Function[]): Function;
export function series(tasks: any[] | Iterable<any> | any, callback?: Function): void;
declare function setImmediate$1(fn: any, ...args: any[]): void;
export function some(obj: any, iteratee: any, callback: any): any;
export function someLimit(obj: any, limit: any, iteratee: any, callback: any): any;
export function someSeries(iterable: any, iteratee: any, callback: any): any;
export function sortBy(coll: any[] | Iterable<any> | any, iteratee: Function, callback: Function): void;
export function timeout(asyncFn: Function, milliseconds: number, info?: any): Function;
export function times(iterable: any, iteratee: any, callback: any): any;
declare function timeLimit(count: number, limit: number, iteratee: Function, callback: Function): void;
export function timesSeries(iterable: any, iteratee: any, callback: any): any;
export function transform(coll: any[] | Iterable<any> | any, accumulator?: any, iteratee: Function, callback?: Function, ...args: any[]): void;
export function tryEach(tasks: any[] | Iterable<any> | any, callback?: Function): void;
export function unmemoize(fn: Function): Function;
export function until(test: Function, iteratee: Function, callback?: Function): void;
export function waterfall(tasks: any[], callback?: Function): any;
export function whilst(test: Function, iteratee: Function, callback?: Function): any;
export { eachLimit as each, eachLimit$1 as eachLimit, parallelLimit as parallel, parallelLimit$1 as parallelLimit, queue$1 as queue, setImmediate$1 as setImmediate, timeLimit as timesLimit, every as all, everyLimit as allLimit, everySeries as allSeries, some as any, someLimit as anyLimit, someSeries as anySeries, detect as find, detectLimit as findLimit, detectSeries as findSeries, eachLimit as forEach, eachSeries as forEachSeries, eachLimit$1 as forEachLimit, eachOf as forEachOf, eachOfSeries as forEachOfSeries, eachOfLimit as forEachOfLimit, reduce as inject, reduce as foldl, reduceRight as foldr, filter as select, filterLimit as selectLimit, filterSeries as selectSeries, asyncify as wrapSync };
