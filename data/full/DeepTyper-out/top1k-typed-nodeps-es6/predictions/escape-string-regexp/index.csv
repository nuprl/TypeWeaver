exportKeyword
 Text.Whitespace
defaultKeyword
 Text.Whitespace
functionKeyword.Declaration
 Text.Whitespace
escapeStringRegexpName.Otherstring0.2625any0.0903complex0.0461string[]0.0341Promise<any>0.0207
(Punctuation
stringKeyword.Type
)Punctuation
 Text.Whitespace
{Punctuation
\n\tText.Whitespace
ifKeyword
 Text.Whitespace
(Punctuation
typeofOperator.Word
 Text.Whitespace
stringKeyword.Type
 Text.Whitespace
!==Operator
 Text.Whitespace
'string'Literal.String.Single
)Punctuation
 Text.Whitespace
{Punctuation
\n\t\tText.Whitespace
throwKeywordcomplex0.4021any0.2616string0.2313boolean0.0447{}0.0126
 Text.Whitespace
newOperator.Wordstring0.3169any0.1872complex0.1711boolean0.1234string[]0.0407
 Text.Whitespace
TypeErrorName.ExceptionTypeErrorConstructor0.9901ErrorConstructor0.0013BooleanConstructor0.0002MapConstructor0.0002complex0.0001
(Punctuation
'Expected a string'Literal.String.Single
)Punctuation
;Punctuation
\n\tText.Whitespace
}Punctuation
\n\n\tText.Whitespace
// Escape characters with special meaning either inside or outside character sets.Comment.Single
\n\tText.Whitespace
// Use a simple backslash escape when it’s always valid, and a `\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.Comment.Single
\n\tText.Whitespace
returnKeyword
 Text.Whitespace
stringKeyword.Type
\n\t\tText.Whitespace
.Punctuation
replaceName.Othercomplex0.9106any0.0713string0.0070void0.0056Promise<any>0.0006
(Punctuation
/[|\\{}()[\]^$+*?.]/gLiteral.String.Regex
,Punctuation
 Text.Whitespace
'\\$&'Literal.String.Single
)Punctuation
\n\t\tText.Whitespace
.Punctuation
replaceName.Othercomplex0.8696any0.1163string0.0059void0.0036boolean0.0007
(Punctuation
/-/gLiteral.String.Regex
,Punctuation
 Text.Whitespace
'\\x2d'Literal.String.Single
)Punctuation
;Punctuation
\nText.Whitespace
}Punctuation
\nText.Whitespace
