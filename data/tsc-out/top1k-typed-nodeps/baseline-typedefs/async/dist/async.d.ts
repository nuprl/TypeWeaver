export default index;
export const __esModule: boolean;
declare namespace index {
    export { apply };
    export { applyEach$1 as applyEach };
    export { applyEachSeries };
    export { asyncify };
    export { auto };
    export { autoInject };
    export { cargo };
    export { cargo$1 as cargoQueue };
    export { compose };
    export { concat$1 as concat };
    export { concatLimit$1 as concatLimit };
    export { concatSeries$1 as concatSeries };
    export { constant };
    export { detect$1 as detect };
    export { detectLimit$1 as detectLimit };
    export { detectSeries$1 as detectSeries };
    export { dir };
    export { doUntil };
    export { doWhilst$1 as doWhilst };
    export { each };
    export { eachLimit$2 as eachLimit };
    export { eachOf$1 as eachOf };
    export { eachOfLimit$2 as eachOfLimit };
    export { eachOfSeries$1 as eachOfSeries };
    export { eachSeries$1 as eachSeries };
    export { ensureAsync };
    export { every$1 as every };
    export { everyLimit$1 as everyLimit };
    export { everySeries$1 as everySeries };
    export { filter$1 as filter };
    export { filterLimit$1 as filterLimit };
    export { filterSeries$1 as filterSeries };
    export { forever$1 as forever };
    export { groupBy };
    export { groupByLimit$1 as groupByLimit };
    export { groupBySeries };
    export { log };
    export { map$1 as map };
    export { mapLimit$1 as mapLimit };
    export { mapSeries$1 as mapSeries };
    export { mapValues };
    export { mapValuesLimit$1 as mapValuesLimit };
    export { mapValuesSeries };
    export { memoize };
    export { nextTick };
    export { parallel$1 as parallel };
    export { parallelLimit };
    export { priorityQueue };
    export { queue$1 as queue };
    export { race$1 as race };
    export { reduce$1 as reduce };
    export { reduceRight };
    export { reflect };
    export { reflectAll };
    export { reject$2 as reject };
    export { rejectLimit$1 as rejectLimit };
    export { rejectSeries$1 as rejectSeries };
    export { retry };
    export { retryable };
    export { seq };
    export { series };
    export { setImmediate$1 as setImmediate };
    export { some$1 as some };
    export { someLimit$1 as someLimit };
    export { someSeries$1 as someSeries };
    export { sortBy$1 as sortBy };
    export { timeout };
    export { times };
    export { timesLimit };
    export { timesSeries };
    export { transform };
    export { tryEach$1 as tryEach };
    export { unmemoize };
    export { until };
    export { waterfall$1 as waterfall };
    export { whilst$1 as whilst };
    export { every$1 as all };
    export { everyLimit$1 as allLimit };
    export { everySeries$1 as allSeries };
    export { some$1 as any };
    export { someLimit$1 as anyLimit };
    export { someSeries$1 as anySeries };
    export { detect$1 as find };
    export { detectLimit$1 as findLimit };
    export { detectSeries$1 as findSeries };
    export { concat$1 as flatMap };
    export { concatLimit$1 as flatMapLimit };
    export { concatSeries$1 as flatMapSeries };
    export { each as forEach };
    export { eachSeries$1 as forEachSeries };
    export { eachLimit$2 as forEachLimit };
    export { eachOf$1 as forEachOf };
    export { eachOfSeries$1 as forEachOfSeries };
    export { eachOfLimit$2 as forEachOfLimit };
    export { reduce$1 as inject };
    export { reduce$1 as foldl };
    export { reduceRight as foldr };
    export { filter$1 as select };
    export { filterLimit$1 as selectLimit };
    export { filterSeries$1 as selectSeries };
    export { asyncify as wrapSync };
    export { whilst$1 as during };
    export { doWhilst$1 as doDuring };
}
export function apply(fn: Function, ...args: any[]): Function;
declare function applyEach$1(fns: any, ...callArgs: any[]): (...args: any[]) => any;
export function applyEachSeries(fns: any, ...callArgs: any[]): (...args: any[]) => any;
export function asyncify(func: Function): Function;
export function auto(tasks: any, concurrency?: number, callback?: Function): Promise<any>;
export function autoInject(tasks: any, callback?: Function): Promise<any>;
export function cargo(worker: Function, payload?: number): any;
declare function cargo$1(worker: Function, concurrency?: number, payload?: number): any;
export function compose(...args: any[]): Function;
declare function concat$1(...args: any[]): any;
declare function concatLimit$1(...args: any[]): any;
declare function concatSeries$1(...args: any[]): any;
export function constant(...args: any[]): Function;
declare function detect$1(...args: any[]): any;
declare function detectLimit$1(...args: any[]): any;
declare function detectSeries$1(...args: any[]): any;
export function dir(fn: any, ...args: any[]): any;
export function doUntil(iteratee: Function, test: Function, callback?: Function): Promise<any>;
declare function doWhilst$1(...args: any[]): any;
export function each(...args: any[]): any;
declare function eachLimit$2(...args: any[]): any;
declare function eachOf$1(...args: any[]): any;
declare function eachOfLimit$2(...args: any[]): any;
declare function eachOfSeries$1(...args: any[]): any;
declare function eachSeries$1(...args: any[]): any;
export function ensureAsync(fn: Function): Function;
declare function every$1(...args: any[]): any;
declare function everyLimit$1(...args: any[]): any;
declare function everySeries$1(...args: any[]): any;
declare function filter$1(...args: any[]): any;
declare function filterLimit$1(...args: any[]): any;
declare function filterSeries$1(...args: any[]): any;
declare function forever$1(...args: any[]): any;
export function groupBy(coll: any[] | Iterable<any> | AsyncIterable<any> | any, iteratee: Function, callback?: Function): Promise<any>;
declare function groupByLimit$1(...args: any[]): any;
export function groupBySeries(coll: any[] | Iterable<any> | AsyncIterable<any> | any, iteratee: Function, callback?: Function): Promise<any>;
export function log(fn: any, ...args: any[]): any;
declare function map$1(...args: any[]): any;
declare function mapLimit$1(...args: any[]): any;
declare function mapSeries$1(...args: any[]): any;
export function mapValues(obj: any, iteratee: Function, callback?: Function): Promise<any>;
declare function mapValuesLimit$1(...args: any[]): any;
export function mapValuesSeries(obj: any, iteratee: Function, callback?: Function): Promise<any>;
export function memoize(fn: Function, hasher?: Function): Function;
export function nextTick(fn: any, ...args: any[]): any;
declare function parallel$1(tasks: any[] | Iterable<any> | AsyncIterable<any> | any, callback?: Function): Promise<any>;
export function parallelLimit(tasks: any[] | Iterable<any> | AsyncIterable<any> | any, limit: number, callback?: Function): Promise<any>;
export function priorityQueue(worker: Function, concurrency: number): any;
declare function queue$1(worker: Function, concurrency?: number): any;
declare function race$1(...args: any[]): any;
declare function reduce$1(...args: any[]): any;
export function reduceRight(array: any[], memo: any, iteratee: Function, callback?: Function): Promise<any>;
export function reflect(fn: Function): Function;
export function reflectAll(tasks: any[] | any | Iterable<any>): any[];
declare function reject$2(...args: any[]): any;
declare function rejectLimit$1(...args: any[]): any;
declare function rejectSeries$1(...args: any[]): any;
export function retry(opts: any, task: any, callback: any, ...args: any[]): any;
export function retryable(opts?: any | number, task: Function): Function;
export function seq(...functions: Function[]): Function;
export function series(tasks: any[] | Iterable<any> | AsyncIterable<any> | any, callback?: Function): Promise<any>;
declare function setImmediate$1(fn: any, ...args: any[]): any;
declare function some$1(...args: any[]): any;
declare function someLimit$1(...args: any[]): any;
declare function someSeries$1(...args: any[]): any;
declare function sortBy$1(...args: any[]): any;
export function timeout(asyncFn: Function, milliseconds: number, info?: any): Function;
export function times(n: number, iteratee: Function, callback: Function): Promise<any>;
export function timesLimit(count: number, limit: number, iteratee: Function, callback: Function): Promise<any>;
export function timesSeries(n: number, iteratee: Function, callback: Function): Promise<any>;
export function transform(coll: any[] | Iterable<any> | AsyncIterable<any> | any, accumulator?: any, iteratee: Function, callback?: Function, ...args: any[]): Promise<any>;
declare function tryEach$1(...args: any[]): any;
export function unmemoize(fn: Function): Function;
export function until(test: Function, iteratee: Function, callback?: Function): Promise<any>;
declare function waterfall$1(...args: any[]): any;
declare function whilst$1(...args: any[]): any;
export { applyEach$1 as applyEach, cargo$1 as cargoQueue, concat$1 as concat, concatLimit$1 as concatLimit, concatSeries$1 as concatSeries, detect$1 as detect, detectLimit$1 as detectLimit, detectSeries$1 as detectSeries, doWhilst$1 as doWhilst, eachLimit$2 as eachLimit, eachOf$1 as eachOf, eachOfLimit$2 as eachOfLimit, eachOfSeries$1 as eachOfSeries, eachSeries$1 as eachSeries, every$1 as every, everyLimit$1 as everyLimit, everySeries$1 as everySeries, filter$1 as filter, filterLimit$1 as filterLimit, filterSeries$1 as filterSeries, forever$1 as forever, groupByLimit$1 as groupByLimit, map$1 as map, mapLimit$1 as mapLimit, mapSeries$1 as mapSeries, mapValuesLimit$1 as mapValuesLimit, parallel$1 as parallel, queue$1 as queue, race$1 as race, reduce$1 as reduce, reject$2 as reject, rejectLimit$1 as rejectLimit, rejectSeries$1 as rejectSeries, setImmediate$1 as setImmediate, some$1 as some, someLimit$1 as someLimit, someSeries$1 as someSeries, sortBy$1 as sortBy, tryEach$1 as tryEach, waterfall$1 as waterfall, whilst$1 as whilst, every$1 as all, everyLimit$1 as allLimit, everySeries$1 as allSeries, some$1 as any, someLimit$1 as anyLimit, someSeries$1 as anySeries, detect$1 as find, detectLimit$1 as findLimit, detectSeries$1 as findSeries, concat$1 as flatMap, concatLimit$1 as flatMapLimit, concatSeries$1 as flatMapSeries, each as forEach, eachSeries$1 as forEachSeries, eachLimit$2 as forEachLimit, eachOf$1 as forEachOf, eachOfSeries$1 as forEachOfSeries, eachOfLimit$2 as forEachOfLimit, reduce$1 as inject, reduce$1 as foldl, reduceRight as foldr, filter$1 as select, filterLimit$1 as selectLimit, filterSeries$1 as selectSeries, asyncify as wrapSync, whilst$1 as during, doWhilst$1 as doDuring };
